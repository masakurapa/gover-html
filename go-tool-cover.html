
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cover: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/masakurapa/gover-html/internal/cover/cover.go (90.6%)</option>
				
				<option value="file1">github.com/masakurapa/gover-html/internal/cover/filter/filter.go (100.0%)</option>
				
				<option value="file2">github.com/masakurapa/gover-html/internal/cover/func.go (82.5%)</option>
				
				<option value="file3">github.com/masakurapa/gover-html/internal/html/html.go (95.4%)</option>
				
				<option value="file4">github.com/masakurapa/gover-html/internal/html/template.go (100.0%)</option>
				
				<option value="file5">github.com/masakurapa/gover-html/internal/html/tree/tree.go (100.0%)</option>
				
				<option value="file6">github.com/masakurapa/gover-html/internal/option/error.go (0.0%)</option>
				
				<option value="file7">github.com/masakurapa/gover-html/internal/option/option.go (96.3%)</option>
				
				<option value="file8">github.com/masakurapa/gover-html/internal/profile/profile.go (92.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cover

import (
        "bufio"
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "os/exec"
        "path"
        "path/filepath"
        "regexp"
        "runtime"
        "sort"
        "strconv"
        "strings"

        "github.com/masakurapa/gover-html/internal/cover/filter"
        "github.com/masakurapa/gover-html/internal/profile"
)

var reg = regexp.MustCompile(`^(.+):([0-9]+)\.([0-9]+),([0-9]+)\.([0-9]+) ([0-9]+) ([0-9]+)$`)

type importDir struct {
        modulePath string
        relative   string
        dir        string
}

// ReadProfile is reads profiling data
func ReadProfile(r io.Reader, f filter.Filter) (profile.Profiles, error) <span class="cov8" title="1">{
        files := make(map[string]*profile.Profile)
        modeOk := false
        id := 1

        s := bufio.NewScanner(r)
        for s.Scan() </span><span class="cov8" title="1">{
                line := s.Text()

                // first line must be "mode: xxx"
                if !modeOk </span><span class="cov8" title="1">{
                        const p = "mode: "
                        if !strings.HasPrefix(line, p) || line == p </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("first line must be mode: %q", line)
                        }</span>
                        <span class="cov8" title="1">modeOk = true
                        continue</span>
                }

                <span class="cov8" title="1">matches := reg.FindStringSubmatch(line)
                if matches == nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%q does not match expected format: %v", line, reg)
                }</span>

                <span class="cov8" title="1">fileName := matches[1]
                p := files[fileName]

                if p == nil </span><span class="cov8" title="1">{
                        p = &amp;profile.Profile{ID: id, FileName: fileName}
                        files[fileName] = p
                        id++
                }</span>

                <span class="cov8" title="1">p.Blocks = append(p.Blocks, profile.Block{
                        StartLine: toInt(matches[2]),
                        StartCol:  toInt(matches[3]),
                        EndLine:   toInt(matches[4]),
                        EndCol:    toInt(matches[5]),
                        NumState:  toInt(matches[6]),
                        Count:     toInt(matches[7]),
                })</span>
        }

        <span class="cov8" title="1">return toProfiles(files, f)</span>
}

func toInt(s string) int <span class="cov8" title="1">{
        i, err := strconv.Atoi(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return i</span>
}

func toProfiles(files map[string]*profile.Profile, f filter.Filter) (profile.Profiles, error) <span class="cov8" title="1">{
        dirs, err := makeImportDirMap(files)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">profiles := make(profile.Profiles, 0, len(files))
        for _, p := range files </span><span class="cov8" title="1">{
                p.Blocks = filterBlocks(p.Blocks)
                sort.SliceStable(p.Blocks, func(i, j int) bool </span><span class="cov8" title="1">{
                        bi, bj := p.Blocks[i], p.Blocks[j]
                        return bi.StartLine &lt; bj.StartLine || bi.StartLine == bj.StartLine &amp;&amp; bi.StartCol &lt; bj.StartCol
                }</span>)

                <span class="cov8" title="1">d := dirs[path.Dir(p.FileName)]
                if !f.IsOutputTarget(d.relative, filepath.Base(p.FileName)) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">p.Dir = d.dir
                p.ModulePath = d.modulePath

                pp, err := makeNewProfile(p, f)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">profiles = append(profiles, *pp)</span>
        }

        <span class="cov8" title="1">sort.SliceStable(profiles, func(i, j int) bool </span><span class="cov8" title="1">{
                return profiles[i].FileName &lt; profiles[j].FileName
        }</span>)

        <span class="cov8" title="1">return profiles, nil</span>
}

func filterBlocks(blocks []profile.Block) []profile.Block <span class="cov8" title="1">{
        index := func(bs []profile.Block, b *profile.Block) int </span><span class="cov8" title="1">{
                for i, bb := range bs </span><span class="cov8" title="1">{
                        if bb.StartLine == b.StartLine &amp;&amp;
                                bb.StartCol == b.StartCol &amp;&amp;
                                bb.EndLine == b.EndLine &amp;&amp;
                                bb.EndCol == b.EndCol </span><span class="cov8" title="1">{
                                return i
                        }</span>
                }
                <span class="cov8" title="1">return -1</span>
        }

        <span class="cov8" title="1">newBlocks := make([]profile.Block, 0, len(blocks))
        for _, b := range blocks </span><span class="cov8" title="1">{
                i := index(newBlocks, &amp;b)
                if i == -1 </span><span class="cov8" title="1">{
                        newBlocks = append(newBlocks, b)
                        continue</span>
                }
                <span class="cov8" title="1">if b.Count &gt; 0 </span><span class="cov8" title="1">{
                        newBlocks[i] = b
                }</span>
        }

        <span class="cov8" title="1">return newBlocks</span>
}

func makeImportDirMap(files map[string]*profile.Profile) (map[string]importDir, error) <span class="cov8" title="1">{
        stdout, err := execGoList(files)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">pkgs := make(map[string]importDir)
        if len(stdout) == 0 </span><span class="cov0" title="0">{
                return pkgs, nil
        }</span>

        <span class="cov8" title="1">type pkg struct {
                Dir    string
                Module *struct {
                        Path string
                        Dir  string
                }
                ImportPath string
                Error      *struct {
                        Err string
                }
        }

        dec := json.NewDecoder(bytes.NewReader(stdout))
        for </span><span class="cov8" title="1">{
                var p pkg
                err := dec.Decode(&amp;p)
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("decoding go list json: %v", err)
                }</span>
                <span class="cov8" title="1">if p.Error != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(p.Error.Err)
                }</span>
                // should have the same result for "pkg.ImportPath" and "path.Path(Profile.FileName)"
                <span class="cov8" title="1">pkgs[p.ImportPath] = importDir{
                        modulePath: p.Module.Path,
                        relative:   strings.TrimPrefix(p.Dir, p.Module.Dir+"/"),
                        dir:        p.Dir,
                }</span>
        }

        <span class="cov8" title="1">return pkgs, nil</span>
}

// execute "go list" command
func execGoList(files map[string]*profile.Profile) ([]byte, error) <span class="cov8" title="1">{
        dirs := make([]string, 0, len(files))
        m := make(map[string]struct{})

        for _, p := range files </span><span class="cov8" title="1">{
                if p.IsRelativeOrAbsolute() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">dir := path.Dir(p.FileName)
                if _, ok := m[dir]; !ok </span><span class="cov8" title="1">{
                        m[dir] = struct{}{}
                        dirs = append(dirs, dir)
                }</span>
        }

        <span class="cov8" title="1">if len(dirs) == 0 </span><span class="cov0" title="0">{
                return make([]byte, 0), nil
        }</span>

        <span class="cov8" title="1">cmdName := filepath.Join(runtime.GOROOT(), "bin/go")
        args := append([]string{"list", "-e", "-json"}, dirs...)
        cmd := exec.Command(cmdName, args...)

        return cmd.Output()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package filter

import (
        "path/filepath"
        "strings"

        "github.com/masakurapa/gover-html/internal/option"
)

// Filter is filter the output directory
type Filter interface {
        IsOutputTarget(string, string) bool
        IsOutputTargetFunc(string, string, string) bool
}

type filter struct {
        opt option.Option
}

// New is initialize the filter
func New(opt option.Option) Filter <span class="cov8" title="1">{
        return &amp;filter{opt: opt}
}</span>

// IsOutputTarget returns true if output target
// The "relativePath" must be relative to the base path
func (f *filter) IsOutputTarget(relativePath, fileName string) bool <span class="cov8" title="1">{
        // absolute path is always NG
        if strings.HasPrefix(relativePath, "/") </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">path := f.convertPathForValidate(relativePath)

        for _, s := range f.opt.Exclude </span><span class="cov8" title="1">{
                if f.hasPrefix(path, fileName, s) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">if len(f.opt.Include) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">for _, s := range f.opt.Include </span><span class="cov8" title="1">{
                if f.hasPrefix(path, fileName, s) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (f *filter) IsOutputTargetFunc(relativePath, structName, funcName string) bool <span class="cov8" title="1">{
        path := f.convertPathForValidate(relativePath)
        dir := filepath.Dir(path)

        for _, opt := range f.opt.ExcludeFunc </span><span class="cov8" title="1">{
                if opt.Path != "" &amp;&amp; opt.Path != path &amp;&amp; opt.Path != dir </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if opt.Struct != "" &amp;&amp; opt.Struct != structName </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if opt.Func != funcName </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (f *filter) hasPrefix(path, fileName, prefix string) bool <span class="cov8" title="1">{
        if path == prefix || strings.HasPrefix(path, prefix+"/") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return path+"/"+fileName == prefix</span>
}

func (f *filter) convertPathForValidate(relativePath string) string <span class="cov8" title="1">{
        path := strings.TrimPrefix(relativePath, "./")
        return strings.TrimSuffix(path, "/")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cover

import (
        "bytes"
        "go/ast"
        "go/format"
        "go/parser"
        "go/token"

        "github.com/masakurapa/gover-html/internal/cover/filter"
        "github.com/masakurapa/gover-html/internal/profile"
)

type funcExtent struct {
        structName string
        funcName   string
        name       string
        startLine  int
        startCol   int
        endLine    int
        endCol     int
}

type funcVisitor struct {
        fset    *token.FileSet
        name    string
        astFile *ast.File
        funcs   []*funcExtent
}

func (v *funcVisitor) Visit(node ast.Node) ast.Visitor <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *ast.FuncDecl:<span class="cov8" title="1">
                if n.Body == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">start := v.fset.Position(n.Pos())
                end := v.fset.Position(n.End())

                var buf bytes.Buffer
                err := format.Node(&amp;buf, token.NewFileSet(), &amp;ast.FuncDecl{
                        Name: n.Name,
                        Recv: n.Recv,
                        Type: n.Type,
                })
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">src, err := format.Source(buf.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov8" title="1">var structName string
                if n.Recv != nil &amp;&amp; len(n.Recv.List) &gt; 0 </span><span class="cov8" title="1">{
                        if t, ok := n.Recv.List[0].Type.(*ast.Ident); ok </span><span class="cov8" title="1">{
                                structName = t.Name
                        }</span>
                        <span class="cov8" title="1">if t, ok := n.Recv.List[0].Type.(*ast.StarExpr); ok </span><span class="cov8" title="1">{
                                structName = t.X.(*ast.Ident).Name
                        }</span>
                }

                <span class="cov8" title="1">fe := &amp;funcExtent{
                        structName: structName,
                        funcName:   n.Name.Name,
                        name:       string(src),
                        startLine:  start.Line,
                        startCol:   start.Column,
                        endLine:    end.Line,
                        endCol:     end.Column,
                }
                v.funcs = append(v.funcs, fe)</span>
        }
        <span class="cov8" title="1">return v</span>
}

func makeNewProfile(prof *profile.Profile, f filter.Filter) (*profile.Profile, error) <span class="cov8" title="1">{
        exts, err := findFuncs(prof.FilePath())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return newProfile(prof, exts, f), nil</span>
}

func findFuncs(name string) ([]*funcExtent, error) <span class="cov8" title="1">{
        fset := token.NewFileSet()
        parsedFile, err := parser.ParseFile(fset, name, nil, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">visitor := &amp;funcVisitor{
                fset:    fset,
                name:    name,
                astFile: parsedFile,
        }
        ast.Walk(visitor, visitor.astFile)
        return visitor.funcs, nil</span>
}

func newProfile(prof *profile.Profile, exts []*funcExtent, f filter.Filter) *profile.Profile <span class="cov8" title="1">{
        fncs := make(profile.Functions, 0, len(exts))
        blocks := make(profile.Blocks, 0, len(prof.Blocks))

        bi := 0
        for _, e := range exts </span><span class="cov8" title="1">{
                isCoverageBlock := f.IsOutputTargetFunc(prof.RemoveModulePathFromFileName(), e.structName, e.funcName)

                fnc := profile.Function{
                        Name:      e.name,
                        StartLine: e.startLine,
                        StartCol:  e.startCol,
                }

                for bi &lt; len(prof.Blocks) </span><span class="cov8" title="1">{
                        b := prof.Blocks[bi]

                        if b.StartLine &lt; e.startLine </span><span class="cov8" title="1">{
                                if isCoverageBlock </span><span class="cov8" title="1">{
                                        blocks = append(blocks, b)
                                }</span>
                                <span class="cov8" title="1">bi++
                                continue</span>
                        }

                        <span class="cov8" title="1">if b.StartLine &gt;= e.startLine &amp;&amp;
                                b.EndLine &lt;= e.endLine </span><span class="cov0" title="0">{
                                fnc.Blocks = append(fnc.Blocks, b)
                                if isCoverageBlock </span><span class="cov0" title="0">{
                                        blocks = append(blocks, b)
                                }</span>
                                <span class="cov0" title="0">bi++
                                continue</span>
                        }
                        <span class="cov8" title="1">break</span>
                }

                <span class="cov8" title="1">if isCoverageBlock </span><span class="cov8" title="1">{
                        fncs = append(fncs, fnc)
                }</span>
        }

        <span class="cov8" title="1">prof.Blocks = blocks
        prof.Functions = fncs
        return prof</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package html

import (
        "bytes"
        "fmt"
        "html/template"
        "io"
        "os"
        "path"

        "github.com/masakurapa/gover-html/internal/html/tree"
        "github.com/masakurapa/gover-html/internal/option"
        "github.com/masakurapa/gover-html/internal/profile"
)

var (
        escapeChar = map[byte]string{
                '&lt;':  "&amp;lt;",
                '&gt;':  "&amp;gt;",
                '&amp;':  "&amp;amp;",
                '\t': "        ",
        }
)

type templateData struct {
        Theme string
        Tree  []templateTree
        Files []templateFile
}

type templateTree struct {
        ID       int
        Name     string
        Indent   int
        Coverage float64
        IsFile   bool
}

type templateFile struct {
        ID        int
        Name      string
        Body      template.HTML
        Coverage  float64
        Functions []templateFunc
}

type templateFunc struct {
        Name     string
        Line     int
        Coverage float64
}

// WriteTreeView outputs coverage as a tree view HTML file
func WriteTreeView(out io.Writer, profiles profile.Profiles, opt option.Option) error <span class="cov8" title="1">{
        nodes := tree.Create(profiles)
        tmpTree := make([]templateTree, 0)
        makeTemplateTree(&amp;tmpTree, nodes, 0)

        data := templateData{
                Theme: opt.Theme,
                Tree:  tmpTree,
                Files: make([]templateFile, 0, len(profiles)),
        }

        var buf bytes.Buffer
        for _, p := range profiles </span><span class="cov8" title="1">{
                b, err := os.ReadFile(p.FilePath())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't read %q: %v", p.FileName, err)
                }</span>

                <span class="cov8" title="1">writeSource(&amp;buf, b, &amp;p)
                f := templateFile{
                        ID:        p.ID,
                        Name:      p.FileName,
                        Body:      template.HTML(buf.String()),
                        Coverage:  p.Blocks.Coverage(),
                        Functions: make([]templateFunc, 0, len(p.Functions)),
                }
                buf.Reset()

                for _, fn := range p.Functions </span><span class="cov0" title="0">{
                        f.Functions = append(f.Functions, templateFunc{
                                Name:     fn.Name,
                                Line:     fn.StartLine,
                                Coverage: fn.Blocks.Coverage(),
                        })
                }</span>

                <span class="cov8" title="1">data.Files = append(data.Files, f)</span>
        }

        <span class="cov8" title="1">return parsedTreeTemplate.Execute(out, data)</span>
}

func makeTemplateTree(tree *[]templateTree, nodes []tree.Node, indent int) <span class="cov8" title="1">{
        for _, node := range nodes </span><span class="cov8" title="1">{
                childBlocks := node.ChildBlocks()
                *tree = append(*tree, templateTree{
                        Name:     node.Name,
                        Indent:   indent,
                        Coverage: childBlocks.Coverage(),
                })

                makeTemplateTree(tree, node.Dirs, indent+1)

                for _, p := range node.Files </span><span class="cov8" title="1">{
                        *tree = append(*tree, templateTree{
                                ID:       p.ID,
                                Name:     path.Base(p.FileName),
                                Indent:   indent + 1,
                                Coverage: p.Blocks.Coverage(),
                                IsFile:   true,
                        })
                }</span>
        }
}

func writeSource(buf *bytes.Buffer, src []byte, prof *profile.Profile) <span class="cov8" title="1">{
        bi := 0
        si := 0
        line := 1
        col := 1
        cov0 := false
        cov1 := false

        buf.WriteString("&lt;ol&gt;")

        for si &lt; len(src) </span><span class="cov8" title="1">{
                if col == 1 </span><span class="cov8" title="1">{
                        buf.WriteString(fmt.Sprintf(`&lt;li id="file%d-%d"&gt;`, prof.ID, line))
                        if cov0 </span><span class="cov0" title="0">{
                                buf.WriteString(`&lt;span class="cov0"&gt;`)
                        }</span>
                        <span class="cov8" title="1">if cov1 </span><span class="cov8" title="1">{
                                buf.WriteString(`&lt;span class="cov1"&gt;`)
                        }</span>
                }

                <span class="cov8" title="1">if len(prof.Blocks) &gt; bi </span><span class="cov8" title="1">{
                        block := prof.Blocks[bi]
                        if block.StartLine == line &amp;&amp; block.StartCol == col </span><span class="cov8" title="1">{
                                if block.Count == 0 </span><span class="cov8" title="1">{
                                        buf.WriteString(`&lt;span class="cov0"&gt;`)
                                        cov0 = true
                                }</span> else<span class="cov8" title="1"> {
                                        buf.WriteString(`&lt;span class="cov1"&gt;`)
                                        cov1 = true
                                }</span>
                        }
                        <span class="cov8" title="1">if block.EndLine == line &amp;&amp; block.EndCol == col || line &gt; block.EndLine </span><span class="cov8" title="1">{
                                buf.WriteString(`&lt;/span&gt;`)
                                bi++
                                cov0 = false
                                cov1 = false
                                continue</span>
                        }
                }

                <span class="cov8" title="1">b := src[si]
                writeChar(buf, b)

                if b == '\n' </span><span class="cov8" title="1">{
                        if cov0 || cov1 </span><span class="cov8" title="1">{
                                buf.WriteString("&lt;/span&gt;")
                        }</span>
                        <span class="cov8" title="1">buf.WriteString("&lt;/li&gt;")
                        line++
                        col = 0</span>
                }

                <span class="cov8" title="1">si++
                col++</span>
        }

        <span class="cov8" title="1">buf.WriteString("&lt;/ol&gt;")</span>
}

func writeChar(buf *bytes.Buffer, b byte) <span class="cov8" title="1">{
        if s, ok := escapeChar[b]; ok </span><span class="cov8" title="1">{
                buf.WriteString(s)
                return
        }</span>
        <span class="cov8" title="1">buf.WriteByte(b)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package html

import "html/template"

var parsedTreeTemplate = template.
        Must(template.New("html").
                Funcs(template.FuncMap{
                        "indent": func(i int) int <span class="cov8" title="1">{ return i*30 + 8 }</span>,
                }).
                Parse(treeTemplate))

const treeTemplate = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
        &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
                &lt;title&gt;Coverage Report&lt;/title&gt;
                &lt;style&gt;
                        body {
                                margin: 0;
                        }
                        .main {
                                width: 100%;
                                display: flex;
                        }
                        .light {
                                background: #FFFFFF;
                                color: rgb(80, 80, 80);
                        }
                        .dark {
                                background: #000000;
                                color: rgb(160, 160, 160);
                        }

                        #tree {
                                width: 25%;
                                height: 100vh;
                                padding: 8px 0;
                                white-space: nowrap;
                                overflow: scroll;
                                position: sticky;
                                position: -webkit-sticky;
                                top: 0;
                                left: 0;
                                border-right: 1px solid rgb(160, 160, 160);
                        }
                        #tree div {
                                padding: 4px 0;
                        }
                        .clickable {
                                cursor: pointer;
                                color: #3EA6FF;
                                text-decoration: underline;
                        }

                        .current {
                                font-weight: bold;
                        }
                        .light .current {
                                background-color: #E6F0FF;
                        }
                        .dark .current {
                                background-color: #555555;
                        }

                        #coverage {
                                width: 70%;
                                margin-left: 16px;
                                margin-right: 32px;
                        }

                        .source {
                                white-space: nowrap;
                        }
                        pre {
                                counter-reset: line;
                                font-family: Menlo, monospace;
                                font-weight: bold;
                        }
                        ol {
                                list-style: none;
                                counter-reset: number;
                                margin: 0;
                                padding: 0;
                        }
                        li:before {
                                counter-increment: number;
                                content: counter(number);
                                margin-right: 24px;
                                display: inline-block;
                                width: 50px;
                                text-align: right;
                        }
                        .light li:before {
                                color: rgb(200, 200, 200);
                        }
                        .dark li:before {
                                color: rgb(80, 80, 80);
                        }

                        .cov0 {
                                color: rgb(192, 0, 0);
                        }
                        .cov1 {
                                color: rgb(44, 212, 149);
                        }
                        table, tr, td, th {
                                border-collapse: collapse;
                                border:1px solid #BBBBBB;
                        }
                        table {
                                margin: 16px 0 32px 74px;
                        }
                        table .total {
                                min-width: 300px;
                                text-align: left;
                                padding-left: 8px;
                        }
                        table .fnc {
                                min-width: 300px;
                                text-align: left;
                                padding: 0 20px 0 20px;
                        }
                        table .cov {
                                width: 70px;
                                text-align: right;
                                padding-right: 8px;
                        }
                &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
                &lt;div class="main {{.Theme}}"&gt;
                        &lt;div id="tree"&gt;
                        {{range $i, $t := .Tree}}
                                {{if $t.IsFile}}
                                &lt;div class="file clickable" style="padding-inline-start: {{indent $t.Indent}}px;" id="tree{{$t.ID}}" onclick="change({{$t.ID}}, {{$t.Indent}});"&gt;
                                        {{$t.Name}} ({{$t.Coverage}}%)
                                &lt;/div&gt;
                                {{else}}
                                &lt;div style="padding-inline-start: {{indent $t.Indent}}px"&gt;{{$t.Name}}/ ({{$t.Coverage}}%)&lt;/div&gt;
                                {{end}}
                        {{end}}
                        &lt;/div&gt;
                        &lt;div id="coverage"&gt;
                                {{range $i, $f := .Files}}
                                &lt;div id="file{{$f.ID}}"  style="display: none"&gt;
                                        &lt;table&gt;
                                                &lt;tr&gt;&lt;th colspan="2"&gt;Coverages&lt;/th&gt;&lt;/tr&gt;
                                                &lt;tr&gt;&lt;td class="total"&gt;Total&lt;/td&gt;&lt;td class="cov"&gt;{{$f.Coverage}}%&lt;/td&gt;&lt;/tr&gt;
                                                {{range $j, $fn := .Functions}}
                                                &lt;tr&gt;
                                                        &lt;td class="fnc"&gt;&lt;span class="clickable" onclick="scrollById('file{{$f.ID}}-{{$fn.Line}}');"&gt;{{$fn.Name}}&lt;/span&gt;&lt;/td&gt;
                                                        &lt;td class="cov"&gt;{{$fn.Coverage}}%&lt;/td&gt;
                                                &lt;/tr&gt;
                                                {{end}}
                                        &lt;/table&gt;

                                        &lt;div class="source"&gt;
                                                &lt;pre&gt;{{$f.Body}}&lt;/pre&gt;
                                        &lt;/div&gt;
                                &lt;/div&gt;
                                {{end}}
                        &lt;/div&gt;
                &lt;/div&gt;

                &lt;script&gt;
                        // tree max width
                        const scrollWidth = document.getElementById('tree').scrollWidth;

                        let current;
                        let currentTree;
                        updateByQuery();

                        window.addEventListener('popstate', function(e) {
                                updateByQuery();
                        })

                        function updateByQuery() {
                                const searchParams = new URLSearchParams(window.location.search);
                                const n = searchParams.get('n');
                                const i = searchParams.get('i');
                                if (n &amp;&amp; i) {
                                        change(n, i);
                                } 
                        }

                        function select(n) {
                                if (current) {
                                        current.style.display = 'none';
                                }

                                current = document.getElementById('file' + n);
                                if (!current) {
                                        return;
                                }
                                current.style.display = 'block';
                                scrollById('coverage');
                        }
                        function selectTree(n, indent) {
                                if (currentTree) {
                                        currentTree.classList.remove('current');
                                }

                                currentTree = document.getElementById('tree' + n);
                                if (!current) {
                                        return;
                                }
                                currentTree.classList.add('current');
                                currentTree.style.width = scrollWidth - (indent * 30 + 8) + 'px';
                        }
                        function scrollById(id) {
                                const elm = document.getElementById(id);
                                const rect = elm.getBoundingClientRect();
                                document.documentElement.scrollTop = rect.top + window.pageYOffset;
                        }
                        function change(n, i) {
                                select(n);
                                selectTree(n, i);
                                updateUrl(n, i)
                        }
                        function updateUrl(n, i) {
                                const url = new URL(window.location.href);
                                if( !url.searchParams.get('n') ) {
                                        url.searchParams.append('n',n);
                                        url.searchParams.append('i',i);
                                        location.href = url;
                                } else {
                                        if (url.searchParams.get('n') != n || url.searchParams.get('i') != i) {
                                                url.searchParams.set('n',n);
                                                url.searchParams.set('i',i);
                                                history.pushState("", "", url);
                                        }
                                }
                        }
                &lt;/script&gt;
        &lt;/body&gt;
&lt;/html&gt;
`
</pre>
		
		<pre class="file" id="file5" style="display: none">package tree

import (
        "path/filepath"
        "strings"

        "github.com/masakurapa/gover-html/internal/profile"
)

// Node is single node of directory tree
type Node struct {
        Name  string
        Files profile.Profiles
        Dirs  []Node
}

// ChildBlocks returns all child Blocks for Node
func (n *Node) ChildBlocks() profile.Blocks <span class="cov8" title="1">{
        blocks := make(profile.Blocks, 0)
        for _, f := range n.Files </span><span class="cov8" title="1">{
                blocks = append(blocks, f.Blocks...)
        }</span>
        <span class="cov8" title="1">for _, ch := range n.Dirs </span><span class="cov8" title="1">{
                blocks = append(blocks, ch.ChildBlocks()...)
        }</span>
        <span class="cov8" title="1">return blocks</span>
}

// Create returns directory tree
func Create(profiles profile.Profiles) []Node <span class="cov8" title="1">{
        nodes := make([]Node, 0)
        for _, p := range profiles </span><span class="cov8" title="1">{
                idx := index(nodes, p.ModulePath)
                if idx == -1 </span><span class="cov8" title="1">{
                        nodes = append(nodes, Node{Name: p.ModulePath})
                        idx = len(nodes) - 1
                }</span>

                <span class="cov8" title="1">addNode(&amp;nodes[idx].Dirs, strings.Split(p.RemoveModulePathFromFileName(), "/"), &amp;p)</span>
        }

        <span class="cov8" title="1">for i, node := range nodes </span><span class="cov8" title="1">{
                nodes[i].Dirs = mergeSingreDir(node.Dirs)
        }</span>
        <span class="cov8" title="1">return nodes</span>
}

func addNode(nodes *[]Node, paths []string, p *profile.Profile) <span class="cov8" title="1">{
        name := paths[0]
        nextPaths := paths[1:]

        idx := index(*nodes, name)
        if idx == -1 </span><span class="cov8" title="1">{
                *nodes = append(*nodes, Node{Name: name})
                idx = len(*nodes) - 1
        }</span>

        <span class="cov8" title="1">n := *nodes
        if len(nextPaths) == 1 </span><span class="cov8" title="1">{
                n[idx].Files = append(n[idx].Files, *p)
                return
        }</span>

        <span class="cov8" title="1">addNode(&amp;n[idx].Dirs, nextPaths, p)</span>
}

func index(nodes []Node, name string) int <span class="cov8" title="1">{
        for i, t := range nodes </span><span class="cov8" title="1">{
                if t.Name == name </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// merge directories with no files and only one child directory
//
//        path/
//                to/
//                file.go
//
// to
//
//        path/to/
//                file.go
func mergeSingreDir(nodes []Node) []Node <span class="cov8" title="1">{
        for i, n := range nodes </span><span class="cov8" title="1">{
                if len(n.Dirs) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">mergeSingreDir(n.Dirs)
                if len(n.Files) &gt; 0 || len(n.Dirs) != 1 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">sub := n.Dirs[0]
                nodes[i].Name = filepath.Join(n.Name, sub.Name)
                nodes[i].Files = sub.Files
                nodes[i].Dirs = sub.Dirs</span>
        }
        <span class="cov8" title="1">return nodes</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package option

import "strings"

type optionErrors []error

func (e *optionErrors) Error() string <span class="cov0" title="0">{
        messages := make([]string, 0, len(*e))
        for _, err := range *e </span><span class="cov0" title="0">{
                messages = append(messages, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(messages, "\n")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package option

import (
        "fmt"
        "io"
        "regexp"
        "strings"

        "github.com/masakurapa/gover-html/internal/reader"

        "gopkg.in/yaml.v2"
)

const (
        fileName = ".gover.yml"

        optionSeparator = ","

        inputDefault  = "coverage.out"
        outputDefault = "coverage.html"

        themeDark    = "dark"
        themeLight   = "light"
        themeDefault = themeDark
)

var (
        // 関数除外設定の検証用の正規表現（ここでは緩い検証にする）
        excludeFuncFormat = regexp.MustCompile(`^\((.+)\)\.([a-zA-Z].+)$`)
)

type optionConfig struct {
        Input       string
        Output      string
        Theme       string
        Include     []string // include fire or directories
        Exclude     []string // exclude fire or directories
        ExcludeFunc []string `yaml:"exclude-func"` // exclude functions
}

type Option struct {
        Input       string
        Output      string
        Theme       string
        Include     []string            // include fire or directories
        Exclude     []string            // exclude fire or directories
        ExcludeFunc []ExcludeFuncOption // exclude functions
}

type ExcludeFuncOption struct {
        Path   string
        Struct string
        Func   string
}

type Generator struct {
        r reader.Reader
}

func New(r reader.Reader) *Generator <span class="cov8" title="1">{
        return &amp;Generator{r: r}
}</span>

func (g *Generator) Generate(
        input *string,
        output *string,
        theme *string,
        include *string,
        exclude *string,
        excludeFunc *string,
) (*Option, error) <span class="cov8" title="1">{
        opt := &amp;optionConfig{}
        if g.r.Exists(fileName) </span><span class="cov8" title="1">{
                fileOpt, err := g.readOptionFile()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">opt = fileOpt</span>
        }

        <span class="cov8" title="1">opt.Input = g.stringValue(input, opt.Input)
        opt.Output = g.stringValue(output, opt.Output)
        opt.Theme = g.stringValue(theme, opt.Theme)
        opt.Include = g.stringsValue(include, opt.Include)
        opt.Exclude = g.stringsValue(exclude, opt.Exclude)
        opt.ExcludeFunc = g.stringsValue(excludeFunc, opt.ExcludeFunc)
        return g.getValidatedOption(opt)</span>
}

func (g *Generator) readOptionFile() (*optionConfig, error) <span class="cov8" title="1">{
        r, err := g.r.Read(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">b, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">opt := optionConfig{}
        if err := yaml.Unmarshal(b, &amp;opt); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;opt, nil</span>
}

func (g *Generator) stringValue(arg *string, opt string) string <span class="cov8" title="1">{
        if arg == nil </span><span class="cov8" title="1">{
                return opt
        }</span>
        <span class="cov8" title="1">return *arg</span>
}

func (g *Generator) stringsValue(arg *string, opt []string) []string <span class="cov8" title="1">{
        if arg == nil </span><span class="cov8" title="1">{
                return opt
        }</span>
        <span class="cov8" title="1">return strings.Split(*arg, optionSeparator)</span>
}

func (g *Generator) getValidatedOption(opt *optionConfig) (*Option, error) <span class="cov8" title="1">{
        if err := g.validate(opt); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return g.getOptionWithDefaultValue(opt), nil</span>
}

func (g *Generator) validate(opt *optionConfig) error <span class="cov8" title="1">{
        errs := make(optionErrors, 0)

        if !g.isEmpty(opt.Theme) &amp;&amp; opt.Theme != themeDark &amp;&amp; opt.Theme != themeLight </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("theme must be %q or %q", themeDark, themeLight))
        }</span>

        <span class="cov8" title="1">if es := g.validateFilter("include", opt.Include); len(es) &gt; 0 </span><span class="cov8" title="1">{
                errs = append(errs, es...)
        }</span>
        <span class="cov8" title="1">if es := g.validateFilter("exclude", opt.Exclude); len(es) &gt; 0 </span><span class="cov8" title="1">{
                errs = append(errs, es...)
        }</span>
        <span class="cov8" title="1">if es := g.validateExcludeFunc(opt.ExcludeFunc); len(es) &gt; 0 </span><span class="cov8" title="1">{
                errs = append(errs, es...)
        }</span>

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;errs
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (g *Generator) validateFilter(f string, values []string) optionErrors <span class="cov8" title="1">{
        errs := make(optionErrors, 0)
        for _, v := range values </span><span class="cov8" title="1">{
                if g.isEmpty(v) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(v, "/") </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("%s value %q must not be an absolute path", f, v))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func (g *Generator) validateExcludeFunc(values []string) optionErrors <span class="cov8" title="1">{
        errs := make(optionErrors, 0)
        for _, v := range values </span><span class="cov8" title="1">{
                if g.isEmpty(v) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(v, "(/") </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("exclude-func value %q must not be an absolute path", v))
                        continue</span>
                }

                // ()が含まれない場合は関数名のみとみなしてOK
                <span class="cov8" title="1">if !strings.Contains(v, "(") &amp;&amp; !strings.Contains(v, ")") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !excludeFuncFormat.MatchString(v) </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("exclude-func value %q format is invalid", v))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func (g *Generator) getOptionWithDefaultValue(opt *optionConfig) *Option <span class="cov8" title="1">{
        newOpt := &amp;Option{
                Input:   opt.Input,
                Output:  opt.Output,
                Theme:   opt.Theme,
                Include: opt.Include,
                Exclude: opt.Exclude,
        }

        if g.isEmpty(newOpt.Input) </span><span class="cov8" title="1">{
                newOpt.Input = inputDefault
        }</span>
        <span class="cov8" title="1">if g.isEmpty(newOpt.Output) </span><span class="cov8" title="1">{
                newOpt.Output = outputDefault
        }</span>
        <span class="cov8" title="1">if g.isEmpty(newOpt.Theme) </span><span class="cov8" title="1">{
                newOpt.Theme = themeDefault
        }</span>

        <span class="cov8" title="1">newOpt.Include = g.convertFilterValue(newOpt.Include)
        newOpt.Exclude = g.convertFilterValue(newOpt.Exclude)
        newOpt.ExcludeFunc = g.convertExcludeFuncOption(opt.ExcludeFunc)
        return newOpt</span>
}

func (g *Generator) isEmpty(s string) bool <span class="cov8" title="1">{
        return s == ""
}</span>

func (g *Generator) convertFilterValue(values []string) []string <span class="cov8" title="1">{
        ret := make([]string, 0, len(values))
        for _, v := range values </span><span class="cov8" title="1">{
                s := strings.TrimSpace(v)
                if g.isEmpty(s) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">s = strings.TrimPrefix(s, "./")
                s = strings.TrimSuffix(s, "/")
                ret = append(ret, s)</span>
        }
        <span class="cov8" title="1">return ret</span>
}

func (g *Generator) convertExcludeFuncOption(values []string) []ExcludeFuncOption <span class="cov8" title="1">{
        ret := make([]ExcludeFuncOption, 0, len(values))
        for _, v := range values </span><span class="cov8" title="1">{
                s := strings.TrimSpace(v)
                if g.isEmpty(s) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // ()が含まれない場合は関数名のみとみなして終了
                <span class="cov8" title="1">if !strings.Contains(s, "(") &amp;&amp; !strings.Contains(s, ")") </span><span class="cov8" title="1">{
                        ret = append(ret, ExcludeFuncOption{Func: s})
                        continue</span>
                }

                // excludeFuncFormat = regexp.MustCompile(`^\(.+\)\.([a-zA-Z].+)$`)

                <span class="cov8" title="1">matches := excludeFuncFormat.FindStringSubmatch(s)
                optPath := strings.TrimSuffix(strings.TrimPrefix(matches[1], "./"), "/")

                var path, structName string
                idx := strings.LastIndex(optPath, ".")

                if idx == -1 </span><span class="cov8" title="1">{
                        // ファイル名で指定していない or 構造体名未指定
                        path = optPath
                }</span> else<span class="cov8" title="1"> {
                        s := optPath[idx+1:]
                        if s == "go" </span><span class="cov8" title="1">{
                                // ファイル名のみ指定している
                                path = optPath
                        }</span> else<span class="cov8" title="1"> {
                                path = optPath[:idx]
                                structName = s
                        }</span>
                }

                <span class="cov8" title="1">if path == "*" </span><span class="cov8" title="1">{
                        path = ""
                }</span>

                <span class="cov8" title="1">ret = append(ret, ExcludeFuncOption{
                        Path:   strings.TrimSuffix(strings.TrimPrefix(path, "./"), "/"),
                        Struct: structName,
                        Func:   matches[2],
                })</span>
        }
        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package profile

import (
        "math"
        "path"
        "path/filepath"
        "strings"
)

// Profiles is a type that represents a slice of Profile
type Profiles []Profile

// Profile is profiling data for each file
type Profile struct {
        ID         int
        ModulePath string
        Dir        string
        FileName   string
        Blocks     Blocks
        Functions  Functions
}

// Functions is a type that represents a slice of Function
type Functions []Function

// Function is single func of profiling data
type Function struct {
        Name      string
        StartLine int
        StartCol  int
        Blocks    Blocks
}

// Blocks is a type that represents a slice of Block
type Blocks []Block

// Block is single block of profiling data
type Block struct {
        StartLine int
        StartCol  int
        EndLine   int
        EndCol    int
        NumState  int
        Count     int
}

// IsRelativeOrAbsolute returns true if FileName is relative path or absolute path
func (prof *Profile) IsRelativeOrAbsolute() bool <span class="cov8" title="1">{
        return strings.HasPrefix(prof.FileName, ".") || filepath.IsAbs(prof.FileName)
}</span>

// RemoveModulePathFromFileName returns FileName with ModulePath removed
func (prof *Profile) RemoveModulePathFromFileName() string <span class="cov0" title="0">{
        return strings.TrimPrefix(strings.TrimPrefix(prof.FileName, prof.ModulePath), "/")
}</span>

// FilePath returns readable file path
func (prof *Profile) FilePath() string <span class="cov8" title="1">{
        if prof.IsRelativeOrAbsolute() </span><span class="cov8" title="1">{
                return prof.FileName
        }</span>
        <span class="cov8" title="1">return filepath.Join(prof.Dir, path.Base(prof.FileName))</span>
}

// Coverage returns covered ratio for file
func (blocks *Blocks) Coverage() float64 <span class="cov8" title="1">{
        var total, covered int64
        for _, b := range *blocks </span><span class="cov8" title="1">{
                total += int64(b.NumState)
                if b.Count &gt; 0 </span><span class="cov8" title="1">{
                        covered += int64(b.NumState)
                }</span>
        }

        <span class="cov8" title="1">if total == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return math.Round((float64(covered)/float64(total)*100)*10) / 10</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
