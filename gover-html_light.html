<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Coverage Report</title>
		<style>
			body {
				margin: 0;
			}
			.main {
				width: 100%;
				display: flex;
			}
			.light {
				background: #FFFFFF;
				color: rgb(80, 80, 80);
			}
			.dark {
				background: #000000;
				color: rgb(160, 160, 160);
			}

			#tree {
				width: 25%;
				height: 100vh;
				padding: 8px 0;
				white-space: nowrap;
				overflow: scroll;
				position: sticky;
				position: -webkit-sticky;
				top: 0;
				left: 0;
				border-right: 1px solid rgb(160, 160, 160);
			}
			#tree div {
				padding: 4px 0;
			}
			.clickable {
				cursor: pointer;
				color: #3EA6FF;
				text-decoration: underline;
			}

			.current {
				font-weight: bold;
			}
			.light .current {
				background-color: #E6F0FF;
			}
			.dark .current {
				background-color: #555555;
			}

			#coverage {
				width: 70%;
				margin-left: 16px;
				margin-right: 32px;
			}

			.source {
				white-space: nowrap;
			}
			pre {
				counter-reset: line;
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			ol {
				list-style: none;
				counter-reset: number;
				margin: 0;
				padding: 0;
			}
			li:before {
				counter-increment: number;
				content: counter(number);
				margin-right: 24px;
				display: inline-block;
				width: 50px;
				text-align: right;
			}
			.light li:before {
				color: rgb(200, 200, 200);
			}
			.dark li:before {
				color: rgb(80, 80, 80);
			}

			.cov0 {
				color: rgb(192, 0, 0);
			}
			.cov1 {
				color: rgb(44, 212, 149);
			}
			table, tr, td, th {
				border-collapse: collapse;
				border:1px solid #BBBBBB;
			}
			table {
				margin: 16px 0 32px 74px;
			}
			table .total {
				min-width: 300px;
				text-align: left;
				padding-left: 8px;
			}
			table .fnc {
				min-width: 300px;
				text-align: left;
				padding: 0 20px 0 20px;
			}
			table .cov {
				width: 70px;
				text-align: right;
				padding-right: 8px;
			}
		</style>
	</head>
	<body>
		<div class="main light">
			<div id="tree">
			
				
				<div style="padding-inline-start: 8px">github.com/masakurapa/gover-html/ (92.5%)</div>
				
			
				
				<div style="padding-inline-start: 38px">internal/ (92.5%)</div>
				
			
				
				<div style="padding-inline-start: 68px">cover/ (89.6%)</div>
				
			
				
				<div style="padding-inline-start: 98px">filter/ (100%)</div>
				
			
				
				<div class="file clickable" style="padding-inline-start: 128px;" id="tree1" onclick="change( 1 ,  4 );">
					filter.go (100%)
				</div>
				
			
				
				<div class="file clickable" style="padding-inline-start: 98px;" id="tree2" onclick="change( 2 ,  3 );">
					cover.go (90.6%)
				</div>
				
			
				
				<div class="file clickable" style="padding-inline-start: 98px;" id="tree3" onclick="change( 3 ,  3 );">
					func.go (82.5%)
				</div>
				
			
				
				<div style="padding-inline-start: 68px">html/ (97.2%)</div>
				
			
				
				<div style="padding-inline-start: 98px">tree/ (100%)</div>
				
			
				
				<div class="file clickable" style="padding-inline-start: 128px;" id="tree6" onclick="change( 6 ,  4 );">
					tree.go (100%)
				</div>
				
			
				
				<div class="file clickable" style="padding-inline-start: 98px;" id="tree4" onclick="change( 4 ,  3 );">
					html.go (95.4%)
				</div>
				
			
				
				<div class="file clickable" style="padding-inline-start: 98px;" id="tree5" onclick="change( 5 ,  3 );">
					template.go (0%)
				</div>
				
			
				
				<div style="padding-inline-start: 68px">option/ (92.9%)</div>
				
			
				
				<div class="file clickable" style="padding-inline-start: 98px;" id="tree7" onclick="change( 7 ,  3 );">
					error.go (0%)
				</div>
				
			
				
				<div class="file clickable" style="padding-inline-start: 98px;" id="tree8" onclick="change( 8 ,  3 );">
					option.go (96.3%)
				</div>
				
			
				
				<div style="padding-inline-start: 68px">profile/ (92.3%)</div>
				
			
				
				<div class="file clickable" style="padding-inline-start: 98px;" id="tree9" onclick="change( 9 ,  3 );">
					profile.go (92.3%)
				</div>
				
			
			</div>
			<div id="coverage">
				
				<div id="file2"  style="display: none">
					<table>
						<tr><th colspan="2">Coverages</th></tr>
						<tr><td class="total">Total</td><td class="cov">90.6%</td></tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file2-31');">func ReadProfile(r io.Reader, f filter.Filter) (profile.Profiles, error)</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file2-77');">func toInt(s string) int</span></td>
							<td class="cov">75%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file2-85');">func toProfiles(files map[string]*profile.Profile, f filter.Filter) (profile.Profiles, error)</span></td>
							<td class="cov">90.5%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file2-121');">func filterBlocks(blocks []profile.Block) []profile.Block</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file2-149');">func makeImportDirMap(files map[string]*profile.Profile) (map[string]importDir, error)</span></td>
							<td class="cov">78.9%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file2-197');">func execGoList(files map[string]*profile.Profile) ([]byte, error)</span></td>
							<td class="cov">86.7%</td>
						</tr>
						
					</table>

					<div class="source">
						<pre><ol><li id="file2-1">package cover
</li><li id="file2-2">
</li><li id="file2-3">import (
</li><li id="file2-4">        "bufio"
</li><li id="file2-5">        "bytes"
</li><li id="file2-6">        "encoding/json"
</li><li id="file2-7">        "fmt"
</li><li id="file2-8">        "io"
</li><li id="file2-9">        "os/exec"
</li><li id="file2-10">        "path"
</li><li id="file2-11">        "path/filepath"
</li><li id="file2-12">        "regexp"
</li><li id="file2-13">        "runtime"
</li><li id="file2-14">        "sort"
</li><li id="file2-15">        "strconv"
</li><li id="file2-16">        "strings"
</li><li id="file2-17">
</li><li id="file2-18">        "github.com/masakurapa/gover-html/internal/cover/filter"
</li><li id="file2-19">        "github.com/masakurapa/gover-html/internal/profile"
</li><li id="file2-20">)
</li><li id="file2-21">
</li><li id="file2-22">var reg = regexp.MustCompile(`^(.+):([0-9]+)\.([0-9]+),([0-9]+)\.([0-9]+) ([0-9]+) ([0-9]+)$`)
</li><li id="file2-23">
</li><li id="file2-24">type importDir struct {
</li><li id="file2-25">        modulePath string
</li><li id="file2-26">        relative   string
</li><li id="file2-27">        dir        string
</li><li id="file2-28">}
</li><li id="file2-29">
</li><li id="file2-30">// ReadProfile is reads profiling data
</li><li id="file2-31">func ReadProfile(r io.Reader, f filter.Filter) (profile.Profiles, error) <span class="cov1">{
</span></li><li id="file2-32"><span class="cov1">        files := make(map[string]*profile.Profile)
</span></li><li id="file2-33"><span class="cov1">        modeOk := false
</span></li><li id="file2-34"><span class="cov1">        id := 1
</span></li><li id="file2-35"><span class="cov1">
</span></li><li id="file2-36"><span class="cov1">        s := bufio.NewScanner(r)
</span></li><li id="file2-37"><span class="cov1">        for s.Scan() </span><span class="cov1">{
</span></li><li id="file2-38"><span class="cov1">                line := s.Text()
</span></li><li id="file2-39"><span class="cov1">
</span></li><li id="file2-40"><span class="cov1">                // first line must be "mode: xxx"
</span></li><li id="file2-41"><span class="cov1">                if !modeOk </span><span class="cov1">{
</span></li><li id="file2-42"><span class="cov1">                        const p = "mode: "
</span></li><li id="file2-43"><span class="cov1">                        if !strings.HasPrefix(line, p) || line == p </span><span class="cov1">{
</span></li><li id="file2-44"><span class="cov1">                                return nil, fmt.Errorf("first line must be mode: %q", line)
</span></li><li id="file2-45"><span class="cov1">                        }</span>
</li><li id="file2-46">                        <span class="cov1">modeOk = true
</span></li><li id="file2-47"><span class="cov1">                        continue</span>
</li><li id="file2-48">                }
</li><li id="file2-49">
</li><li id="file2-50">                <span class="cov1">matches := reg.FindStringSubmatch(line)
</span></li><li id="file2-51"><span class="cov1">                if matches == nil </span><span class="cov1">{
</span></li><li id="file2-52"><span class="cov1">                        return nil, fmt.Errorf("%q does not match expected format: %v", line, reg)
</span></li><li id="file2-53"><span class="cov1">                }</span>
</li><li id="file2-54">
</li><li id="file2-55">                <span class="cov1">fileName := matches[1]
</span></li><li id="file2-56"><span class="cov1">                p := files[fileName]
</span></li><li id="file2-57"><span class="cov1">
</span></li><li id="file2-58"><span class="cov1">                if p == nil </span><span class="cov1">{
</span></li><li id="file2-59"><span class="cov1">                        p = &amp;profile.Profile{ID: id, FileName: fileName}
</span></li><li id="file2-60"><span class="cov1">                        files[fileName] = p
</span></li><li id="file2-61"><span class="cov1">                        id++
</span></li><li id="file2-62"><span class="cov1">                }</span>
</li><li id="file2-63">
</li><li id="file2-64">                <span class="cov1">p.Blocks = append(p.Blocks, profile.Block{
</span></li><li id="file2-65"><span class="cov1">                        StartLine: toInt(matches[2]),
</span></li><li id="file2-66"><span class="cov1">                        StartCol:  toInt(matches[3]),
</span></li><li id="file2-67"><span class="cov1">                        EndLine:   toInt(matches[4]),
</span></li><li id="file2-68"><span class="cov1">                        EndCol:    toInt(matches[5]),
</span></li><li id="file2-69"><span class="cov1">                        NumState:  toInt(matches[6]),
</span></li><li id="file2-70"><span class="cov1">                        Count:     toInt(matches[7]),
</span></li><li id="file2-71"><span class="cov1">                })</span>
</li><li id="file2-72">        }
</li><li id="file2-73">
</li><li id="file2-74">        <span class="cov1">return toProfiles(files, f)</span>
</li><li id="file2-75">}
</li><li id="file2-76">
</li><li id="file2-77">func toInt(s string) int <span class="cov1">{
</span></li><li id="file2-78"><span class="cov1">        i, err := strconv.Atoi(s)
</span></li><li id="file2-79"><span class="cov1">        if err != nil </span><span class="cov0">{
</span></li><li id="file2-80"><span class="cov0">                panic(err)</span>
</li><li id="file2-81">        }
</li><li id="file2-82">        <span class="cov1">return i</span>
</li><li id="file2-83">}
</li><li id="file2-84">
</li><li id="file2-85">func toProfiles(files map[string]*profile.Profile, f filter.Filter) (profile.Profiles, error) <span class="cov1">{
</span></li><li id="file2-86"><span class="cov1">        dirs, err := makeImportDirMap(files)
</span></li><li id="file2-87"><span class="cov1">        if err != nil </span><span class="cov0">{
</span></li><li id="file2-88"><span class="cov0">                return nil, err
</span></li><li id="file2-89"><span class="cov0">        }</span>
</li><li id="file2-90">
</li><li id="file2-91">        <span class="cov1">profiles := make(profile.Profiles, 0, len(files))
</span></li><li id="file2-92"><span class="cov1">        for _, p := range files </span><span class="cov1">{
</span></li><li id="file2-93"><span class="cov1">                p.Blocks = filterBlocks(p.Blocks)
</span></li><li id="file2-94"><span class="cov1">                sort.SliceStable(p.Blocks, func(i, j int) bool </span><span class="cov1">{
</span></li><li id="file2-95"><span class="cov1">                        bi, bj := p.Blocks[i], p.Blocks[j]
</span></li><li id="file2-96"><span class="cov1">                        return bi.StartLine &lt; bj.StartLine || bi.StartLine == bj.StartLine &amp;&amp; bi.StartCol &lt; bj.StartCol
</span></li><li id="file2-97"><span class="cov1">                }</span>)
</li><li id="file2-98">
</li><li id="file2-99">                <span class="cov1">d := dirs[path.Dir(p.FileName)]
</span></li><li id="file2-100"><span class="cov1">                if !f.IsOutputTarget(d.relative, filepath.Base(p.FileName)) </span><span class="cov1">{
</span></li><li id="file2-101"><span class="cov1">                        continue</span>
</li><li id="file2-102">                }
</li><li id="file2-103">
</li><li id="file2-104">                <span class="cov1">p.Dir = d.dir
</span></li><li id="file2-105"><span class="cov1">                p.ModulePath = d.modulePath
</span></li><li id="file2-106"><span class="cov1">
</span></li><li id="file2-107"><span class="cov1">                pp, err := makeNewProfile(p, f)
</span></li><li id="file2-108"><span class="cov1">                if err != nil </span><span class="cov0">{
</span></li><li id="file2-109"><span class="cov0">                        return nil, err
</span></li><li id="file2-110"><span class="cov0">                }</span>
</li><li id="file2-111">                <span class="cov1">profiles = append(profiles, *pp)</span>
</li><li id="file2-112">        }
</li><li id="file2-113">
</li><li id="file2-114">        <span class="cov1">sort.SliceStable(profiles, func(i, j int) bool </span><span class="cov1">{
</span></li><li id="file2-115"><span class="cov1">                return profiles[i].FileName &lt; profiles[j].FileName
</span></li><li id="file2-116"><span class="cov1">        }</span>)
</li><li id="file2-117">
</li><li id="file2-118">        <span class="cov1">return profiles, nil</span>
</li><li id="file2-119">}
</li><li id="file2-120">
</li><li id="file2-121">func filterBlocks(blocks []profile.Block) []profile.Block <span class="cov1">{
</span></li><li id="file2-122"><span class="cov1">        index := func(bs []profile.Block, b *profile.Block) int </span><span class="cov1">{
</span></li><li id="file2-123"><span class="cov1">                for i, bb := range bs </span><span class="cov1">{
</span></li><li id="file2-124"><span class="cov1">                        if bb.StartLine == b.StartLine &amp;&amp;
</span></li><li id="file2-125"><span class="cov1">                                bb.StartCol == b.StartCol &amp;&amp;
</span></li><li id="file2-126"><span class="cov1">                                bb.EndLine == b.EndLine &amp;&amp;
</span></li><li id="file2-127"><span class="cov1">                                bb.EndCol == b.EndCol </span><span class="cov1">{
</span></li><li id="file2-128"><span class="cov1">                                return i
</span></li><li id="file2-129"><span class="cov1">                        }</span>
</li><li id="file2-130">                }
</li><li id="file2-131">                <span class="cov1">return -1</span>
</li><li id="file2-132">        }
</li><li id="file2-133">
</li><li id="file2-134">        <span class="cov1">newBlocks := make([]profile.Block, 0, len(blocks))
</span></li><li id="file2-135"><span class="cov1">        for _, b := range blocks </span><span class="cov1">{
</span></li><li id="file2-136"><span class="cov1">                i := index(newBlocks, &amp;b)
</span></li><li id="file2-137"><span class="cov1">                if i == -1 </span><span class="cov1">{
</span></li><li id="file2-138"><span class="cov1">                        newBlocks = append(newBlocks, b)
</span></li><li id="file2-139"><span class="cov1">                        continue</span>
</li><li id="file2-140">                }
</li><li id="file2-141">                <span class="cov1">if b.Count &gt; 0 </span><span class="cov1">{
</span></li><li id="file2-142"><span class="cov1">                        newBlocks[i] = b
</span></li><li id="file2-143"><span class="cov1">                }</span>
</li><li id="file2-144">        }
</li><li id="file2-145">
</li><li id="file2-146">        <span class="cov1">return newBlocks</span>
</li><li id="file2-147">}
</li><li id="file2-148">
</li><li id="file2-149">func makeImportDirMap(files map[string]*profile.Profile) (map[string]importDir, error) <span class="cov1">{
</span></li><li id="file2-150"><span class="cov1">        stdout, err := execGoList(files)
</span></li><li id="file2-151"><span class="cov1">        if err != nil </span><span class="cov0">{
</span></li><li id="file2-152"><span class="cov0">                return nil, err
</span></li><li id="file2-153"><span class="cov0">        }</span>
</li><li id="file2-154">
</li><li id="file2-155">        <span class="cov1">pkgs := make(map[string]importDir)
</span></li><li id="file2-156"><span class="cov1">        if len(stdout) == 0 </span><span class="cov0">{
</span></li><li id="file2-157"><span class="cov0">                return pkgs, nil
</span></li><li id="file2-158"><span class="cov0">        }</span>
</li><li id="file2-159">
</li><li id="file2-160">        <span class="cov1">type pkg struct {
</span></li><li id="file2-161"><span class="cov1">                Dir    string
</span></li><li id="file2-162"><span class="cov1">                Module *struct {
</span></li><li id="file2-163"><span class="cov1">                        Path string
</span></li><li id="file2-164"><span class="cov1">                        Dir  string
</span></li><li id="file2-165"><span class="cov1">                }
</span></li><li id="file2-166"><span class="cov1">                ImportPath string
</span></li><li id="file2-167"><span class="cov1">                Error      *struct {
</span></li><li id="file2-168"><span class="cov1">                        Err string
</span></li><li id="file2-169"><span class="cov1">                }
</span></li><li id="file2-170"><span class="cov1">        }
</span></li><li id="file2-171"><span class="cov1">
</span></li><li id="file2-172"><span class="cov1">        dec := json.NewDecoder(bytes.NewReader(stdout))
</span></li><li id="file2-173"><span class="cov1">        for </span><span class="cov1">{
</span></li><li id="file2-174"><span class="cov1">                var p pkg
</span></li><li id="file2-175"><span class="cov1">                err := dec.Decode(&amp;p)
</span></li><li id="file2-176"><span class="cov1">                if err == io.EOF </span><span class="cov1">{
</span></li><li id="file2-177"><span class="cov1">                        break</span>
</li><li id="file2-178">                }
</li><li id="file2-179">                <span class="cov1">if err != nil </span><span class="cov0">{
</span></li><li id="file2-180"><span class="cov0">                        return nil, fmt.Errorf("decoding go list json: %v", err)
</span></li><li id="file2-181"><span class="cov0">                }</span>
</li><li id="file2-182">                <span class="cov1">if p.Error != nil </span><span class="cov0">{
</span></li><li id="file2-183"><span class="cov0">                        return nil, fmt.Errorf(p.Error.Err)
</span></li><li id="file2-184"><span class="cov0">                }</span>
</li><li id="file2-185">                // should have the same result for "pkg.ImportPath" and "path.Path(Profile.FileName)"
</li><li id="file2-186">                <span class="cov1">pkgs[p.ImportPath] = importDir{
</span></li><li id="file2-187"><span class="cov1">                        modulePath: p.Module.Path,
</span></li><li id="file2-188"><span class="cov1">                        relative:   strings.TrimPrefix(p.Dir, p.Module.Dir+"/"),
</span></li><li id="file2-189"><span class="cov1">                        dir:        p.Dir,
</span></li><li id="file2-190"><span class="cov1">                }</span>
</li><li id="file2-191">        }
</li><li id="file2-192">
</li><li id="file2-193">        <span class="cov1">return pkgs, nil</span>
</li><li id="file2-194">}
</li><li id="file2-195">
</li><li id="file2-196">// execute "go list" command
</li><li id="file2-197">func execGoList(files map[string]*profile.Profile) ([]byte, error) <span class="cov1">{
</span></li><li id="file2-198"><span class="cov1">        dirs := make([]string, 0, len(files))
</span></li><li id="file2-199"><span class="cov1">        m := make(map[string]struct{})
</span></li><li id="file2-200"><span class="cov1">
</span></li><li id="file2-201"><span class="cov1">        for _, p := range files </span><span class="cov1">{
</span></li><li id="file2-202"><span class="cov1">                if p.IsRelativeOrAbsolute() </span><span class="cov0">{
</span></li><li id="file2-203"><span class="cov0">                        continue</span>
</li><li id="file2-204">                }
</li><li id="file2-205">                <span class="cov1">dir := path.Dir(p.FileName)
</span></li><li id="file2-206"><span class="cov1">                if _, ok := m[dir]; !ok </span><span class="cov1">{
</span></li><li id="file2-207"><span class="cov1">                        m[dir] = struct{}{}
</span></li><li id="file2-208"><span class="cov1">                        dirs = append(dirs, dir)
</span></li><li id="file2-209"><span class="cov1">                }</span>
</li><li id="file2-210">        }
</li><li id="file2-211">
</li><li id="file2-212">        <span class="cov1">if len(dirs) == 0 </span><span class="cov0">{
</span></li><li id="file2-213"><span class="cov0">                return make([]byte, 0), nil
</span></li><li id="file2-214"><span class="cov0">        }</span>
</li><li id="file2-215">
</li><li id="file2-216">        <span class="cov1">cmdName := filepath.Join(runtime.GOROOT(), "bin/go")
</span></li><li id="file2-217"><span class="cov1">        args := append([]string{"list", "-e", "-json"}, dirs...)
</span></li><li id="file2-218"><span class="cov1">        cmd := exec.Command(cmdName, args...)
</span></li><li id="file2-219"><span class="cov1">
</span></li><li id="file2-220"><span class="cov1">        return cmd.Output()</span>
</li><li id="file2-221">}
</li></ol></pre>
					</div>
				</div>
				
				<div id="file1"  style="display: none">
					<table>
						<tr><th colspan="2">Coverages</th></tr>
						<tr><td class="total">Total</td><td class="cov">100%</td></tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file1-21');">func New(opt option.Option) Filter</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file1-27');">func (f *filter) IsOutputTarget(relativePath, fileName string) bool</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file1-53');">func (f *filter) IsOutputTargetFunc(relativePath, structName, funcName string) bool</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file1-72');">func (f *filter) hasPrefix(path, fileName, prefix string) bool</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file1-79');">func (f *filter) convertPathForValidate(relativePath string) string</span></td>
							<td class="cov">100%</td>
						</tr>
						
					</table>

					<div class="source">
						<pre><ol><li id="file1-1">package filter
</li><li id="file1-2">
</li><li id="file1-3">import (
</li><li id="file1-4">        "path/filepath"
</li><li id="file1-5">        "strings"
</li><li id="file1-6">
</li><li id="file1-7">        "github.com/masakurapa/gover-html/internal/option"
</li><li id="file1-8">)
</li><li id="file1-9">
</li><li id="file1-10">// Filter is filter the output directory
</li><li id="file1-11">type Filter interface {
</li><li id="file1-12">        IsOutputTarget(string, string) bool
</li><li id="file1-13">        IsOutputTargetFunc(string, string, string) bool
</li><li id="file1-14">}
</li><li id="file1-15">
</li><li id="file1-16">type filter struct {
</li><li id="file1-17">        opt option.Option
</li><li id="file1-18">}
</li><li id="file1-19">
</li><li id="file1-20">// New is initialize the filter
</li><li id="file1-21">func New(opt option.Option) Filter <span class="cov1">{
</span></li><li id="file1-22"><span class="cov1">        return &amp;filter{opt: opt}
</span></li><li id="file1-23"><span class="cov1">}</span>
</li><li id="file1-24">
</li><li id="file1-25">// IsOutputTarget returns true if output target
</li><li id="file1-26">// The "relativePath" must be relative to the base path
</li><li id="file1-27">func (f *filter) IsOutputTarget(relativePath, fileName string) bool <span class="cov1">{
</span></li><li id="file1-28"><span class="cov1">        // absolute path is always NG
</span></li><li id="file1-29"><span class="cov1">        if strings.HasPrefix(relativePath, "/") </span><span class="cov1">{
</span></li><li id="file1-30"><span class="cov1">                return false
</span></li><li id="file1-31"><span class="cov1">        }</span>
</li><li id="file1-32">
</li><li id="file1-33">        <span class="cov1">path := f.convertPathForValidate(relativePath)
</span></li><li id="file1-34"><span class="cov1">
</span></li><li id="file1-35"><span class="cov1">        for _, s := range f.opt.Exclude </span><span class="cov1">{
</span></li><li id="file1-36"><span class="cov1">                if f.hasPrefix(path, fileName, s) </span><span class="cov1">{
</span></li><li id="file1-37"><span class="cov1">                        return false
</span></li><li id="file1-38"><span class="cov1">                }</span>
</li><li id="file1-39">        }
</li><li id="file1-40">
</li><li id="file1-41">        <span class="cov1">if len(f.opt.Include) == 0 </span><span class="cov1">{
</span></li><li id="file1-42"><span class="cov1">                return true
</span></li><li id="file1-43"><span class="cov1">        }</span>
</li><li id="file1-44">
</li><li id="file1-45">        <span class="cov1">for _, s := range f.opt.Include </span><span class="cov1">{
</span></li><li id="file1-46"><span class="cov1">                if f.hasPrefix(path, fileName, s) </span><span class="cov1">{
</span></li><li id="file1-47"><span class="cov1">                        return true
</span></li><li id="file1-48"><span class="cov1">                }</span>
</li><li id="file1-49">        }
</li><li id="file1-50">        <span class="cov1">return false</span>
</li><li id="file1-51">}
</li><li id="file1-52">
</li><li id="file1-53">func (f *filter) IsOutputTargetFunc(relativePath, structName, funcName string) bool <span class="cov1">{
</span></li><li id="file1-54"><span class="cov1">        path := f.convertPathForValidate(relativePath)
</span></li><li id="file1-55"><span class="cov1">        dir := filepath.Dir(path)
</span></li><li id="file1-56"><span class="cov1">
</span></li><li id="file1-57"><span class="cov1">        for _, opt := range f.opt.ExcludeFunc </span><span class="cov1">{
</span></li><li id="file1-58"><span class="cov1">                if opt.Path != "" &amp;&amp; opt.Path != path &amp;&amp; opt.Path != dir </span><span class="cov1">{
</span></li><li id="file1-59"><span class="cov1">                        continue</span>
</li><li id="file1-60">                }
</li><li id="file1-61">                <span class="cov1">if opt.Struct != "" &amp;&amp; opt.Struct != structName </span><span class="cov1">{
</span></li><li id="file1-62"><span class="cov1">                        continue</span>
</li><li id="file1-63">                }
</li><li id="file1-64">                <span class="cov1">if opt.Func != funcName </span><span class="cov1">{
</span></li><li id="file1-65"><span class="cov1">                        continue</span>
</li><li id="file1-66">                }
</li><li id="file1-67">                <span class="cov1">return false</span>
</li><li id="file1-68">        }
</li><li id="file1-69">        <span class="cov1">return true</span>
</li><li id="file1-70">}
</li><li id="file1-71">
</li><li id="file1-72">func (f *filter) hasPrefix(path, fileName, prefix string) bool <span class="cov1">{
</span></li><li id="file1-73"><span class="cov1">        if path == prefix || strings.HasPrefix(path, prefix+"/") </span><span class="cov1">{
</span></li><li id="file1-74"><span class="cov1">                return true
</span></li><li id="file1-75"><span class="cov1">        }</span>
</li><li id="file1-76">        <span class="cov1">return path+"/"+fileName == prefix</span>
</li><li id="file1-77">}
</li><li id="file1-78">
</li><li id="file1-79">func (f *filter) convertPathForValidate(relativePath string) string <span class="cov1">{
</span></li><li id="file1-80"><span class="cov1">        path := strings.TrimPrefix(relativePath, "./")
</span></li><li id="file1-81"><span class="cov1">        return strings.TrimSuffix(path, "/")
</span></li><li id="file1-82"><span class="cov1">}</span>
</li></ol></pre>
					</div>
				</div>
				
				<div id="file3"  style="display: none">
					<table>
						<tr><th colspan="2">Coverages</th></tr>
						<tr><td class="total">Total</td><td class="cov">82.5%</td></tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file3-31');">func (v *funcVisitor) Visit(node ast.Node) ast.Visitor</span></td>
							<td class="cov">85.7%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file3-78');">func makeNewProfile(prof *profile.Profile, f filter.Filter) (*profile.Profile, error)</span></td>
							<td class="cov">75%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file3-87');">func findFuncs(name string) ([]*funcExtent, error)</span></td>
							<td class="cov">85.7%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file3-102');">func newProfile(prof *profile.Profile, exts []*funcExtent, f filter.Filter) *profile.Profile</span></td>
							<td class="cov">80%</td>
						</tr>
						
					</table>

					<div class="source">
						<pre><ol><li id="file3-1">package cover
</li><li id="file3-2">
</li><li id="file3-3">import (
</li><li id="file3-4">        "bytes"
</li><li id="file3-5">        "go/ast"
</li><li id="file3-6">        "go/format"
</li><li id="file3-7">        "go/parser"
</li><li id="file3-8">        "go/token"
</li><li id="file3-9">
</li><li id="file3-10">        "github.com/masakurapa/gover-html/internal/cover/filter"
</li><li id="file3-11">        "github.com/masakurapa/gover-html/internal/profile"
</li><li id="file3-12">)
</li><li id="file3-13">
</li><li id="file3-14">type funcExtent struct {
</li><li id="file3-15">        structName string
</li><li id="file3-16">        funcName   string
</li><li id="file3-17">        name       string
</li><li id="file3-18">        startLine  int
</li><li id="file3-19">        startCol   int
</li><li id="file3-20">        endLine    int
</li><li id="file3-21">        endCol     int
</li><li id="file3-22">}
</li><li id="file3-23">
</li><li id="file3-24">type funcVisitor struct {
</li><li id="file3-25">        fset    *token.FileSet
</li><li id="file3-26">        name    string
</li><li id="file3-27">        astFile *ast.File
</li><li id="file3-28">        funcs   []*funcExtent
</li><li id="file3-29">}
</li><li id="file3-30">
</li><li id="file3-31">func (v *funcVisitor) Visit(node ast.Node) ast.Visitor <span class="cov1">{
</span></li><li id="file3-32"><span class="cov1">        switch n := node.(type) </span>{
</li><li id="file3-33">        case *ast.FuncDecl:<span class="cov1">
</span></li><li id="file3-34"><span class="cov1">                if n.Body == nil </span><span class="cov0">{
</span></li><li id="file3-35"><span class="cov0">                        break</span>
</li><li id="file3-36">                }
</li><li id="file3-37">                <span class="cov1">start := v.fset.Position(n.Pos())
</span></li><li id="file3-38"><span class="cov1">                end := v.fset.Position(n.End())
</span></li><li id="file3-39"><span class="cov1">
</span></li><li id="file3-40"><span class="cov1">                var buf bytes.Buffer
</span></li><li id="file3-41"><span class="cov1">                err := format.Node(&amp;buf, token.NewFileSet(), &amp;ast.FuncDecl{
</span></li><li id="file3-42"><span class="cov1">                        Name: n.Name,
</span></li><li id="file3-43"><span class="cov1">                        Recv: n.Recv,
</span></li><li id="file3-44"><span class="cov1">                        Type: n.Type,
</span></li><li id="file3-45"><span class="cov1">                })
</span></li><li id="file3-46"><span class="cov1">                if err != nil </span><span class="cov0">{
</span></li><li id="file3-47"><span class="cov0">                        panic(err)</span>
</li><li id="file3-48">                }
</li><li id="file3-49">                <span class="cov1">src, err := format.Source(buf.Bytes())
</span></li><li id="file3-50"><span class="cov1">                if err != nil </span><span class="cov0">{
</span></li><li id="file3-51"><span class="cov0">                        panic(err)</span>
</li><li id="file3-52">                }
</li><li id="file3-53">
</li><li id="file3-54">                <span class="cov1">var structName string
</span></li><li id="file3-55"><span class="cov1">                if n.Recv != nil &amp;&amp; len(n.Recv.List) &gt; 0 </span><span class="cov1">{
</span></li><li id="file3-56"><span class="cov1">                        if t, ok := n.Recv.List[0].Type.(*ast.Ident); ok </span><span class="cov1">{
</span></li><li id="file3-57"><span class="cov1">                                structName = t.Name
</span></li><li id="file3-58"><span class="cov1">                        }</span>
</li><li id="file3-59">                        <span class="cov1">if t, ok := n.Recv.List[0].Type.(*ast.StarExpr); ok </span><span class="cov1">{
</span></li><li id="file3-60"><span class="cov1">                                structName = t.X.(*ast.Ident).Name
</span></li><li id="file3-61"><span class="cov1">                        }</span>
</li><li id="file3-62">                }
</li><li id="file3-63">
</li><li id="file3-64">                <span class="cov1">fe := &amp;funcExtent{
</span></li><li id="file3-65"><span class="cov1">                        structName: structName,
</span></li><li id="file3-66"><span class="cov1">                        funcName:   n.Name.Name,
</span></li><li id="file3-67"><span class="cov1">                        name:       string(src),
</span></li><li id="file3-68"><span class="cov1">                        startLine:  start.Line,
</span></li><li id="file3-69"><span class="cov1">                        startCol:   start.Column,
</span></li><li id="file3-70"><span class="cov1">                        endLine:    end.Line,
</span></li><li id="file3-71"><span class="cov1">                        endCol:     end.Column,
</span></li><li id="file3-72"><span class="cov1">                }
</span></li><li id="file3-73"><span class="cov1">                v.funcs = append(v.funcs, fe)</span>
</li><li id="file3-74">        }
</li><li id="file3-75">        <span class="cov1">return v</span>
</li><li id="file3-76">}
</li><li id="file3-77">
</li><li id="file3-78">func makeNewProfile(prof *profile.Profile, f filter.Filter) (*profile.Profile, error) <span class="cov1">{
</span></li><li id="file3-79"><span class="cov1">        exts, err := findFuncs(prof.FilePath())
</span></li><li id="file3-80"><span class="cov1">        if err != nil </span><span class="cov0">{
</span></li><li id="file3-81"><span class="cov0">                return nil, err
</span></li><li id="file3-82"><span class="cov0">        }</span>
</li><li id="file3-83">
</li><li id="file3-84">        <span class="cov1">return newProfile(prof, exts, f), nil</span>
</li><li id="file3-85">}
</li><li id="file3-86">
</li><li id="file3-87">func findFuncs(name string) ([]*funcExtent, error) <span class="cov1">{
</span></li><li id="file3-88"><span class="cov1">        fset := token.NewFileSet()
</span></li><li id="file3-89"><span class="cov1">        parsedFile, err := parser.ParseFile(fset, name, nil, 0)
</span></li><li id="file3-90"><span class="cov1">        if err != nil </span><span class="cov0">{
</span></li><li id="file3-91"><span class="cov0">                return nil, err
</span></li><li id="file3-92"><span class="cov0">        }</span>
</li><li id="file3-93">        <span class="cov1">visitor := &amp;funcVisitor{
</span></li><li id="file3-94"><span class="cov1">                fset:    fset,
</span></li><li id="file3-95"><span class="cov1">                name:    name,
</span></li><li id="file3-96"><span class="cov1">                astFile: parsedFile,
</span></li><li id="file3-97"><span class="cov1">        }
</span></li><li id="file3-98"><span class="cov1">        ast.Walk(visitor, visitor.astFile)
</span></li><li id="file3-99"><span class="cov1">        return visitor.funcs, nil</span>
</li><li id="file3-100">}
</li><li id="file3-101">
</li><li id="file3-102">func newProfile(prof *profile.Profile, exts []*funcExtent, f filter.Filter) *profile.Profile <span class="cov1">{
</span></li><li id="file3-103"><span class="cov1">        fncs := make(profile.Functions, 0, len(exts))
</span></li><li id="file3-104"><span class="cov1">        blocks := make(profile.Blocks, 0, len(prof.Blocks))
</span></li><li id="file3-105"><span class="cov1">
</span></li><li id="file3-106"><span class="cov1">        bi := 0
</span></li><li id="file3-107"><span class="cov1">        for _, e := range exts </span><span class="cov1">{
</span></li><li id="file3-108"><span class="cov1">                isCoverageBlock := f.IsOutputTargetFunc(prof.RemoveModulePathFromFileName(), e.structName, e.funcName)
</span></li><li id="file3-109"><span class="cov1">
</span></li><li id="file3-110"><span class="cov1">                fnc := profile.Function{
</span></li><li id="file3-111"><span class="cov1">                        Name:      e.name,
</span></li><li id="file3-112"><span class="cov1">                        StartLine: e.startLine,
</span></li><li id="file3-113"><span class="cov1">                        StartCol:  e.startCol,
</span></li><li id="file3-114"><span class="cov1">                }
</span></li><li id="file3-115"><span class="cov1">
</span></li><li id="file3-116"><span class="cov1">                for bi &lt; len(prof.Blocks) </span><span class="cov1">{
</span></li><li id="file3-117"><span class="cov1">                        b := prof.Blocks[bi]
</span></li><li id="file3-118"><span class="cov1">
</span></li><li id="file3-119"><span class="cov1">                        if b.StartLine &lt; e.startLine </span><span class="cov1">{
</span></li><li id="file3-120"><span class="cov1">                                if isCoverageBlock </span><span class="cov1">{
</span></li><li id="file3-121"><span class="cov1">                                        blocks = append(blocks, b)
</span></li><li id="file3-122"><span class="cov1">                                }</span>
</li><li id="file3-123">                                <span class="cov1">bi++
</span></li><li id="file3-124"><span class="cov1">                                continue</span>
</li><li id="file3-125">                        }
</li><li id="file3-126">
</li><li id="file3-127">                        <span class="cov1">if b.StartLine &gt;= e.startLine &amp;&amp;
</span></li><li id="file3-128"><span class="cov1">                                b.EndLine &lt;= e.endLine </span><span class="cov0">{
</span></li><li id="file3-129"><span class="cov0">                                fnc.Blocks = append(fnc.Blocks, b)
</span></li><li id="file3-130"><span class="cov0">                                if isCoverageBlock </span><span class="cov0">{
</span></li><li id="file3-131"><span class="cov0">                                        blocks = append(blocks, b)
</span></li><li id="file3-132"><span class="cov0">                                }</span>
</li><li id="file3-133">                                <span class="cov0">bi++
</span></li><li id="file3-134"><span class="cov0">                                continue</span>
</li><li id="file3-135">                        }
</li><li id="file3-136">                        <span class="cov1">break</span>
</li><li id="file3-137">                }
</li><li id="file3-138">
</li><li id="file3-139">                <span class="cov1">if isCoverageBlock </span><span class="cov1">{
</span></li><li id="file3-140"><span class="cov1">                        fncs = append(fncs, fnc)
</span></li><li id="file3-141"><span class="cov1">                }</span>
</li><li id="file3-142">        }
</li><li id="file3-143">
</li><li id="file3-144">        <span class="cov1">prof.Blocks = blocks
</span></li><li id="file3-145"><span class="cov1">        prof.Functions = fncs
</span></li><li id="file3-146"><span class="cov1">        return prof</span>
</li><li id="file3-147">}
</li></ol></pre>
					</div>
				</div>
				
				<div id="file4"  style="display: none">
					<table>
						<tr><th colspan="2">Coverages</th></tr>
						<tr><td class="total">Total</td><td class="cov">95.4%</td></tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file4-54');">func WriteTreeView(out io.Writer, profiles profile.Profiles, opt option.Option) error</span></td>
							<td class="cov">87.5%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file4-96');">func makeTemplateTree(tree *[]templateTree, nodes []tree.Node, indent int)</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file4-119');">func writeSource(buf *bytes.Buffer, src []byte, prof *profile.Profile)</span></td>
							<td class="cov">97.4%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file4-179');">func writeChar(buf *bytes.Buffer, b byte)</span></td>
							<td class="cov">100%</td>
						</tr>
						
					</table>

					<div class="source">
						<pre><ol><li id="file4-1">package html
</li><li id="file4-2">
</li><li id="file4-3">import (
</li><li id="file4-4">        "bytes"
</li><li id="file4-5">        "fmt"
</li><li id="file4-6">        "html/template"
</li><li id="file4-7">        "io"
</li><li id="file4-8">        "os"
</li><li id="file4-9">        "path"
</li><li id="file4-10">
</li><li id="file4-11">        "github.com/masakurapa/gover-html/internal/html/tree"
</li><li id="file4-12">        "github.com/masakurapa/gover-html/internal/option"
</li><li id="file4-13">        "github.com/masakurapa/gover-html/internal/profile"
</li><li id="file4-14">)
</li><li id="file4-15">
</li><li id="file4-16">var (
</li><li id="file4-17">        escapeChar = map[byte]string{
</li><li id="file4-18">                '&lt;':  "&amp;lt;",
</li><li id="file4-19">                '&gt;':  "&amp;gt;",
</li><li id="file4-20">                '&amp;':  "&amp;amp;",
</li><li id="file4-21">                '\t': "        ",
</li><li id="file4-22">        }
</li><li id="file4-23">)
</li><li id="file4-24">
</li><li id="file4-25">type templateData struct {
</li><li id="file4-26">        Theme string
</li><li id="file4-27">        Tree  []templateTree
</li><li id="file4-28">        Files []templateFile
</li><li id="file4-29">}
</li><li id="file4-30">
</li><li id="file4-31">type templateTree struct {
</li><li id="file4-32">        ID       int
</li><li id="file4-33">        Name     string
</li><li id="file4-34">        Indent   int
</li><li id="file4-35">        Coverage float64
</li><li id="file4-36">        IsFile   bool
</li><li id="file4-37">}
</li><li id="file4-38">
</li><li id="file4-39">type templateFile struct {
</li><li id="file4-40">        ID        int
</li><li id="file4-41">        Name      string
</li><li id="file4-42">        Body      template.HTML
</li><li id="file4-43">        Coverage  float64
</li><li id="file4-44">        Functions []templateFunc
</li><li id="file4-45">}
</li><li id="file4-46">
</li><li id="file4-47">type templateFunc struct {
</li><li id="file4-48">        Name     string
</li><li id="file4-49">        Line     int
</li><li id="file4-50">        Coverage float64
</li><li id="file4-51">}
</li><li id="file4-52">
</li><li id="file4-53">// WriteTreeView outputs coverage as a tree view HTML file
</li><li id="file4-54">func WriteTreeView(out io.Writer, profiles profile.Profiles, opt option.Option) error <span class="cov1">{
</span></li><li id="file4-55"><span class="cov1">        nodes := tree.Create(profiles)
</span></li><li id="file4-56"><span class="cov1">        tmpTree := make([]templateTree, 0)
</span></li><li id="file4-57"><span class="cov1">        makeTemplateTree(&amp;tmpTree, nodes, 0)
</span></li><li id="file4-58"><span class="cov1">
</span></li><li id="file4-59"><span class="cov1">        data := templateData{
</span></li><li id="file4-60"><span class="cov1">                Theme: opt.Theme,
</span></li><li id="file4-61"><span class="cov1">                Tree:  tmpTree,
</span></li><li id="file4-62"><span class="cov1">                Files: make([]templateFile, 0, len(profiles)),
</span></li><li id="file4-63"><span class="cov1">        }
</span></li><li id="file4-64"><span class="cov1">
</span></li><li id="file4-65"><span class="cov1">        var buf bytes.Buffer
</span></li><li id="file4-66"><span class="cov1">        for _, p := range profiles </span><span class="cov1">{
</span></li><li id="file4-67"><span class="cov1">                b, err := os.ReadFile(p.FilePath())
</span></li><li id="file4-68"><span class="cov1">                if err != nil </span><span class="cov0">{
</span></li><li id="file4-69"><span class="cov0">                        return fmt.Errorf("can't read %q: %v", p.FileName, err)
</span></li><li id="file4-70"><span class="cov0">                }</span>
</li><li id="file4-71">
</li><li id="file4-72">                <span class="cov1">writeSource(&amp;buf, b, &amp;p)
</span></li><li id="file4-73"><span class="cov1">                f := templateFile{
</span></li><li id="file4-74"><span class="cov1">                        ID:        p.ID,
</span></li><li id="file4-75"><span class="cov1">                        Name:      p.FileName,
</span></li><li id="file4-76"><span class="cov1">                        Body:      template.HTML(buf.String()),
</span></li><li id="file4-77"><span class="cov1">                        Coverage:  p.Blocks.Coverage(),
</span></li><li id="file4-78"><span class="cov1">                        Functions: make([]templateFunc, 0, len(p.Functions)),
</span></li><li id="file4-79"><span class="cov1">                }
</span></li><li id="file4-80"><span class="cov1">                buf.Reset()
</span></li><li id="file4-81"><span class="cov1">
</span></li><li id="file4-82"><span class="cov1">                for _, fn := range p.Functions </span><span class="cov0">{
</span></li><li id="file4-83"><span class="cov0">                        f.Functions = append(f.Functions, templateFunc{
</span></li><li id="file4-84"><span class="cov0">                                Name:     fn.Name,
</span></li><li id="file4-85"><span class="cov0">                                Line:     fn.StartLine,
</span></li><li id="file4-86"><span class="cov0">                                Coverage: fn.Blocks.Coverage(),
</span></li><li id="file4-87"><span class="cov0">                        })
</span></li><li id="file4-88"><span class="cov0">                }</span>
</li><li id="file4-89">
</li><li id="file4-90">                <span class="cov1">data.Files = append(data.Files, f)</span>
</li><li id="file4-91">        }
</li><li id="file4-92">
</li><li id="file4-93">        <span class="cov1">return parsedTreeTemplate.Execute(out, data)</span>
</li><li id="file4-94">}
</li><li id="file4-95">
</li><li id="file4-96">func makeTemplateTree(tree *[]templateTree, nodes []tree.Node, indent int) <span class="cov1">{
</span></li><li id="file4-97"><span class="cov1">        for _, node := range nodes </span><span class="cov1">{
</span></li><li id="file4-98"><span class="cov1">                childBlocks := node.ChildBlocks()
</span></li><li id="file4-99"><span class="cov1">                *tree = append(*tree, templateTree{
</span></li><li id="file4-100"><span class="cov1">                        Name:     node.Name,
</span></li><li id="file4-101"><span class="cov1">                        Indent:   indent,
</span></li><li id="file4-102"><span class="cov1">                        Coverage: childBlocks.Coverage(),
</span></li><li id="file4-103"><span class="cov1">                })
</span></li><li id="file4-104"><span class="cov1">
</span></li><li id="file4-105"><span class="cov1">                makeTemplateTree(tree, node.Dirs, indent+1)
</span></li><li id="file4-106"><span class="cov1">
</span></li><li id="file4-107"><span class="cov1">                for _, p := range node.Files </span><span class="cov1">{
</span></li><li id="file4-108"><span class="cov1">                        *tree = append(*tree, templateTree{
</span></li><li id="file4-109"><span class="cov1">                                ID:       p.ID,
</span></li><li id="file4-110"><span class="cov1">                                Name:     path.Base(p.FileName),
</span></li><li id="file4-111"><span class="cov1">                                Indent:   indent + 1,
</span></li><li id="file4-112"><span class="cov1">                                Coverage: p.Blocks.Coverage(),
</span></li><li id="file4-113"><span class="cov1">                                IsFile:   true,
</span></li><li id="file4-114"><span class="cov1">                        })
</span></li><li id="file4-115"><span class="cov1">                }</span>
</li><li id="file4-116">        }
</li><li id="file4-117">}
</li><li id="file4-118">
</li><li id="file4-119">func writeSource(buf *bytes.Buffer, src []byte, prof *profile.Profile) <span class="cov1">{
</span></li><li id="file4-120"><span class="cov1">        bi := 0
</span></li><li id="file4-121"><span class="cov1">        si := 0
</span></li><li id="file4-122"><span class="cov1">        line := 1
</span></li><li id="file4-123"><span class="cov1">        col := 1
</span></li><li id="file4-124"><span class="cov1">        cov0 := false
</span></li><li id="file4-125"><span class="cov1">        cov1 := false
</span></li><li id="file4-126"><span class="cov1">
</span></li><li id="file4-127"><span class="cov1">        buf.WriteString("&lt;ol&gt;")
</span></li><li id="file4-128"><span class="cov1">
</span></li><li id="file4-129"><span class="cov1">        for si &lt; len(src) </span><span class="cov1">{
</span></li><li id="file4-130"><span class="cov1">                if col == 1 </span><span class="cov1">{
</span></li><li id="file4-131"><span class="cov1">                        buf.WriteString(fmt.Sprintf(`&lt;li id="file%d-%d"&gt;`, prof.ID, line))
</span></li><li id="file4-132"><span class="cov1">                        if cov0 </span><span class="cov0">{
</span></li><li id="file4-133"><span class="cov0">                                buf.WriteString(`&lt;span class="cov0"&gt;`)
</span></li><li id="file4-134"><span class="cov0">                        }</span>
</li><li id="file4-135">                        <span class="cov1">if cov1 </span><span class="cov1">{
</span></li><li id="file4-136"><span class="cov1">                                buf.WriteString(`&lt;span class="cov1"&gt;`)
</span></li><li id="file4-137"><span class="cov1">                        }</span>
</li><li id="file4-138">                }
</li><li id="file4-139">
</li><li id="file4-140">                <span class="cov1">if len(prof.Blocks) &gt; bi </span><span class="cov1">{
</span></li><li id="file4-141"><span class="cov1">                        block := prof.Blocks[bi]
</span></li><li id="file4-142"><span class="cov1">                        if block.StartLine == line &amp;&amp; block.StartCol == col </span><span class="cov1">{
</span></li><li id="file4-143"><span class="cov1">                                if block.Count == 0 </span><span class="cov1">{
</span></li><li id="file4-144"><span class="cov1">                                        buf.WriteString(`&lt;span class="cov0"&gt;`)
</span></li><li id="file4-145"><span class="cov1">                                        cov0 = true
</span></li><li id="file4-146"><span class="cov1">                                }</span> else<span class="cov1"> {
</span></li><li id="file4-147"><span class="cov1">                                        buf.WriteString(`&lt;span class="cov1"&gt;`)
</span></li><li id="file4-148"><span class="cov1">                                        cov1 = true
</span></li><li id="file4-149"><span class="cov1">                                }</span>
</li><li id="file4-150">                        }
</li><li id="file4-151">                        <span class="cov1">if block.EndLine == line &amp;&amp; block.EndCol == col || line &gt; block.EndLine </span><span class="cov1">{
</span></li><li id="file4-152"><span class="cov1">                                buf.WriteString(`&lt;/span&gt;`)
</span></li><li id="file4-153"><span class="cov1">                                bi++
</span></li><li id="file4-154"><span class="cov1">                                cov0 = false
</span></li><li id="file4-155"><span class="cov1">                                cov1 = false
</span></li><li id="file4-156"><span class="cov1">                                continue</span>
</li><li id="file4-157">                        }
</li><li id="file4-158">                }
</li><li id="file4-159">
</li><li id="file4-160">                <span class="cov1">b := src[si]
</span></li><li id="file4-161"><span class="cov1">                writeChar(buf, b)
</span></li><li id="file4-162"><span class="cov1">
</span></li><li id="file4-163"><span class="cov1">                if b == '\n' </span><span class="cov1">{
</span></li><li id="file4-164"><span class="cov1">                        if cov0 || cov1 </span><span class="cov1">{
</span></li><li id="file4-165"><span class="cov1">                                buf.WriteString("&lt;/span&gt;")
</span></li><li id="file4-166"><span class="cov1">                        }</span>
</li><li id="file4-167">                        <span class="cov1">buf.WriteString("&lt;/li&gt;")
</span></li><li id="file4-168"><span class="cov1">                        line++
</span></li><li id="file4-169"><span class="cov1">                        col = 0</span>
</li><li id="file4-170">                }
</li><li id="file4-171">
</li><li id="file4-172">                <span class="cov1">si++
</span></li><li id="file4-173"><span class="cov1">                col++</span>
</li><li id="file4-174">        }
</li><li id="file4-175">
</li><li id="file4-176">        <span class="cov1">buf.WriteString("&lt;/ol&gt;")</span>
</li><li id="file4-177">}
</li><li id="file4-178">
</li><li id="file4-179">func writeChar(buf *bytes.Buffer, b byte) <span class="cov1">{
</span></li><li id="file4-180"><span class="cov1">        if s, ok := escapeChar[b]; ok </span><span class="cov1">{
</span></li><li id="file4-181"><span class="cov1">                buf.WriteString(s)
</span></li><li id="file4-182"><span class="cov1">                return
</span></li><li id="file4-183"><span class="cov1">        }</span>
</li><li id="file4-184">        <span class="cov1">buf.WriteByte(b)</span>
</li><li id="file4-185">}
</li></ol></pre>
					</div>
				</div>
				
				<div id="file5"  style="display: none">
					<table>
						<tr><th colspan="2">Coverages</th></tr>
						<tr><td class="total">Total</td><td class="cov">0%</td></tr>
						
					</table>

					<div class="source">
						<pre><ol><li id="file5-1">package html
</li><li id="file5-2">
</li><li id="file5-3">import "html/template"
</li><li id="file5-4">
</li><li id="file5-5">var parsedTreeTemplate = template.
</li><li id="file5-6">        Must(template.New("html").
</li><li id="file5-7">                Funcs(template.FuncMap{
</li><li id="file5-8">                        "indent": func(i int) int { return i*30 + 8 },
</li><li id="file5-9">                }).
</li><li id="file5-10">                Parse(treeTemplate))
</li><li id="file5-11">
</li><li id="file5-12">const treeTemplate = `&lt;!DOCTYPE html&gt;
</li><li id="file5-13">&lt;html&gt;
</li><li id="file5-14">        &lt;head&gt;
</li><li id="file5-15">                &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
</li><li id="file5-16">                &lt;title&gt;Coverage Report&lt;/title&gt;
</li><li id="file5-17">                &lt;style&gt;
</li><li id="file5-18">                        body {
</li><li id="file5-19">                                margin: 0;
</li><li id="file5-20">                        }
</li><li id="file5-21">                        .main {
</li><li id="file5-22">                                width: 100%;
</li><li id="file5-23">                                display: flex;
</li><li id="file5-24">                        }
</li><li id="file5-25">                        .light {
</li><li id="file5-26">                                background: #FFFFFF;
</li><li id="file5-27">                                color: rgb(80, 80, 80);
</li><li id="file5-28">                        }
</li><li id="file5-29">                        .dark {
</li><li id="file5-30">                                background: #000000;
</li><li id="file5-31">                                color: rgb(160, 160, 160);
</li><li id="file5-32">                        }
</li><li id="file5-33">
</li><li id="file5-34">                        #tree {
</li><li id="file5-35">                                width: 25%;
</li><li id="file5-36">                                height: 100vh;
</li><li id="file5-37">                                padding: 8px 0;
</li><li id="file5-38">                                white-space: nowrap;
</li><li id="file5-39">                                overflow: scroll;
</li><li id="file5-40">                                position: sticky;
</li><li id="file5-41">                                position: -webkit-sticky;
</li><li id="file5-42">                                top: 0;
</li><li id="file5-43">                                left: 0;
</li><li id="file5-44">                                border-right: 1px solid rgb(160, 160, 160);
</li><li id="file5-45">                        }
</li><li id="file5-46">                        #tree div {
</li><li id="file5-47">                                padding: 4px 0;
</li><li id="file5-48">                        }
</li><li id="file5-49">                        .clickable {
</li><li id="file5-50">                                cursor: pointer;
</li><li id="file5-51">                                color: #3EA6FF;
</li><li id="file5-52">                                text-decoration: underline;
</li><li id="file5-53">                        }
</li><li id="file5-54">
</li><li id="file5-55">                        .current {
</li><li id="file5-56">                                font-weight: bold;
</li><li id="file5-57">                        }
</li><li id="file5-58">                        .light .current {
</li><li id="file5-59">                                background-color: #E6F0FF;
</li><li id="file5-60">                        }
</li><li id="file5-61">                        .dark .current {
</li><li id="file5-62">                                background-color: #555555;
</li><li id="file5-63">                        }
</li><li id="file5-64">
</li><li id="file5-65">                        #coverage {
</li><li id="file5-66">                                width: 70%;
</li><li id="file5-67">                                margin-left: 16px;
</li><li id="file5-68">                                margin-right: 32px;
</li><li id="file5-69">                        }
</li><li id="file5-70">
</li><li id="file5-71">                        .source {
</li><li id="file5-72">                                white-space: nowrap;
</li><li id="file5-73">                        }
</li><li id="file5-74">                        pre {
</li><li id="file5-75">                                counter-reset: line;
</li><li id="file5-76">                                font-family: Menlo, monospace;
</li><li id="file5-77">                                font-weight: bold;
</li><li id="file5-78">                        }
</li><li id="file5-79">                        ol {
</li><li id="file5-80">                                list-style: none;
</li><li id="file5-81">                                counter-reset: number;
</li><li id="file5-82">                                margin: 0;
</li><li id="file5-83">                                padding: 0;
</li><li id="file5-84">                        }
</li><li id="file5-85">                        li:before {
</li><li id="file5-86">                                counter-increment: number;
</li><li id="file5-87">                                content: counter(number);
</li><li id="file5-88">                                margin-right: 24px;
</li><li id="file5-89">                                display: inline-block;
</li><li id="file5-90">                                width: 50px;
</li><li id="file5-91">                                text-align: right;
</li><li id="file5-92">                        }
</li><li id="file5-93">                        .light li:before {
</li><li id="file5-94">                                color: rgb(200, 200, 200);
</li><li id="file5-95">                        }
</li><li id="file5-96">                        .dark li:before {
</li><li id="file5-97">                                color: rgb(80, 80, 80);
</li><li id="file5-98">                        }
</li><li id="file5-99">
</li><li id="file5-100">                        .cov0 {
</li><li id="file5-101">                                color: rgb(192, 0, 0);
</li><li id="file5-102">                        }
</li><li id="file5-103">                        .cov1 {
</li><li id="file5-104">                                color: rgb(44, 212, 149);
</li><li id="file5-105">                        }
</li><li id="file5-106">                        table, tr, td, th {
</li><li id="file5-107">                                border-collapse: collapse;
</li><li id="file5-108">                                border:1px solid #BBBBBB;
</li><li id="file5-109">                        }
</li><li id="file5-110">                        table {
</li><li id="file5-111">                                margin: 16px 0 32px 74px;
</li><li id="file5-112">                        }
</li><li id="file5-113">                        table .total {
</li><li id="file5-114">                                min-width: 300px;
</li><li id="file5-115">                                text-align: left;
</li><li id="file5-116">                                padding-left: 8px;
</li><li id="file5-117">                        }
</li><li id="file5-118">                        table .fnc {
</li><li id="file5-119">                                min-width: 300px;
</li><li id="file5-120">                                text-align: left;
</li><li id="file5-121">                                padding: 0 20px 0 20px;
</li><li id="file5-122">                        }
</li><li id="file5-123">                        table .cov {
</li><li id="file5-124">                                width: 70px;
</li><li id="file5-125">                                text-align: right;
</li><li id="file5-126">                                padding-right: 8px;
</li><li id="file5-127">                        }
</li><li id="file5-128">                &lt;/style&gt;
</li><li id="file5-129">        &lt;/head&gt;
</li><li id="file5-130">        &lt;body&gt;
</li><li id="file5-131">                &lt;div class="main {{.Theme}}"&gt;
</li><li id="file5-132">                        &lt;div id="tree"&gt;
</li><li id="file5-133">                        {{range $i, $t := .Tree}}
</li><li id="file5-134">                                {{if $t.IsFile}}
</li><li id="file5-135">                                &lt;div class="file clickable" style="padding-inline-start: {{indent $t.Indent}}px;" id="tree{{$t.ID}}" onclick="change({{$t.ID}}, {{$t.Indent}});"&gt;
</li><li id="file5-136">                                        {{$t.Name}} ({{$t.Coverage}}%)
</li><li id="file5-137">                                &lt;/div&gt;
</li><li id="file5-138">                                {{else}}
</li><li id="file5-139">                                &lt;div style="padding-inline-start: {{indent $t.Indent}}px"&gt;{{$t.Name}}/ ({{$t.Coverage}}%)&lt;/div&gt;
</li><li id="file5-140">                                {{end}}
</li><li id="file5-141">                        {{end}}
</li><li id="file5-142">                        &lt;/div&gt;
</li><li id="file5-143">                        &lt;div id="coverage"&gt;
</li><li id="file5-144">                                {{range $i, $f := .Files}}
</li><li id="file5-145">                                &lt;div id="file{{$f.ID}}"  style="display: none"&gt;
</li><li id="file5-146">                                        &lt;table&gt;
</li><li id="file5-147">                                                &lt;tr&gt;&lt;th colspan="2"&gt;Coverages&lt;/th&gt;&lt;/tr&gt;
</li><li id="file5-148">                                                &lt;tr&gt;&lt;td class="total"&gt;Total&lt;/td&gt;&lt;td class="cov"&gt;{{$f.Coverage}}%&lt;/td&gt;&lt;/tr&gt;
</li><li id="file5-149">                                                {{range $j, $fn := .Functions}}
</li><li id="file5-150">                                                &lt;tr&gt;
</li><li id="file5-151">                                                        &lt;td class="fnc"&gt;&lt;span class="clickable" onclick="scrollById('file{{$f.ID}}-{{$fn.Line}}');"&gt;{{$fn.Name}}&lt;/span&gt;&lt;/td&gt;
</li><li id="file5-152">                                                        &lt;td class="cov"&gt;{{$fn.Coverage}}%&lt;/td&gt;
</li><li id="file5-153">                                                &lt;/tr&gt;
</li><li id="file5-154">                                                {{end}}
</li><li id="file5-155">                                        &lt;/table&gt;
</li><li id="file5-156">
</li><li id="file5-157">                                        &lt;div class="source"&gt;
</li><li id="file5-158">                                                &lt;pre&gt;{{$f.Body}}&lt;/pre&gt;
</li><li id="file5-159">                                        &lt;/div&gt;
</li><li id="file5-160">                                &lt;/div&gt;
</li><li id="file5-161">                                {{end}}
</li><li id="file5-162">                        &lt;/div&gt;
</li><li id="file5-163">                &lt;/div&gt;
</li><li id="file5-164">
</li><li id="file5-165">                &lt;script&gt;
</li><li id="file5-166">                        // tree max width
</li><li id="file5-167">                        const scrollWidth = document.getElementById('tree').scrollWidth;
</li><li id="file5-168">
</li><li id="file5-169">                        let current;
</li><li id="file5-170">                        let currentTree;
</li><li id="file5-171">                        updateByQuery();
</li><li id="file5-172">
</li><li id="file5-173">                        window.addEventListener('popstate', function(e) {
</li><li id="file5-174">                                updateByQuery();
</li><li id="file5-175">                        })
</li><li id="file5-176">
</li><li id="file5-177">                        function updateByQuery() {
</li><li id="file5-178">                                const searchParams = new URLSearchParams(window.location.search);
</li><li id="file5-179">                                const n = searchParams.get('n');
</li><li id="file5-180">                                const i = searchParams.get('i');
</li><li id="file5-181">                                if (n &amp;&amp; i) {
</li><li id="file5-182">                                        change(n, i);
</li><li id="file5-183">                                } 
</li><li id="file5-184">                        }
</li><li id="file5-185">
</li><li id="file5-186">                        function select(n) {
</li><li id="file5-187">                                if (current) {
</li><li id="file5-188">                                        current.style.display = 'none';
</li><li id="file5-189">                                }
</li><li id="file5-190">
</li><li id="file5-191">                                current = document.getElementById('file' + n);
</li><li id="file5-192">                                if (!current) {
</li><li id="file5-193">                                        return;
</li><li id="file5-194">                                }
</li><li id="file5-195">                                current.style.display = 'block';
</li><li id="file5-196">                                scrollById('coverage');
</li><li id="file5-197">                        }
</li><li id="file5-198">                        function selectTree(n, indent) {
</li><li id="file5-199">                                if (currentTree) {
</li><li id="file5-200">                                        currentTree.classList.remove('current');
</li><li id="file5-201">                                }
</li><li id="file5-202">
</li><li id="file5-203">                                currentTree = document.getElementById('tree' + n);
</li><li id="file5-204">                                if (!current) {
</li><li id="file5-205">                                        return;
</li><li id="file5-206">                                }
</li><li id="file5-207">                                currentTree.classList.add('current');
</li><li id="file5-208">                                currentTree.style.width = scrollWidth - (indent * 30 + 8) + 'px';
</li><li id="file5-209">                        }
</li><li id="file5-210">                        function scrollById(id) {
</li><li id="file5-211">                                const elm = document.getElementById(id);
</li><li id="file5-212">                                const rect = elm.getBoundingClientRect();
</li><li id="file5-213">                                document.documentElement.scrollTop = rect.top + window.pageYOffset;
</li><li id="file5-214">                        }
</li><li id="file5-215">                        function change(n, i) {
</li><li id="file5-216">                                select(n);
</li><li id="file5-217">                                selectTree(n, i);
</li><li id="file5-218">                                updateUrl(n, i)
</li><li id="file5-219">                        }
</li><li id="file5-220">                        function updateUrl(n, i) {
</li><li id="file5-221">                                const url = new URL(window.location.href);
</li><li id="file5-222">                                if( !url.searchParams.get('n') ) {
</li><li id="file5-223">                                        url.searchParams.append('n',n);
</li><li id="file5-224">                                        url.searchParams.append('i',i);
</li><li id="file5-225">                                        location.href = url;
</li><li id="file5-226">                                } else {
</li><li id="file5-227">                                        if (url.searchParams.get('n') != n || url.searchParams.get('i') != i) {
</li><li id="file5-228">                                                url.searchParams.set('n',n);
</li><li id="file5-229">                                                url.searchParams.set('i',i);
</li><li id="file5-230">                                                history.pushState("", "", url);
</li><li id="file5-231">                                        }
</li><li id="file5-232">                                }
</li><li id="file5-233">                        }
</li><li id="file5-234">                &lt;/script&gt;
</li><li id="file5-235">        &lt;/body&gt;
</li><li id="file5-236">&lt;/html&gt;
</li><li id="file5-237">`
</li></ol></pre>
					</div>
				</div>
				
				<div id="file6"  style="display: none">
					<table>
						<tr><th colspan="2">Coverages</th></tr>
						<tr><td class="total">Total</td><td class="cov">100%</td></tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file6-18');">func (n *Node) ChildBlocks() profile.Blocks</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file6-30');">func Create(profiles profile.Profiles) []Node</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file6-48');">func addNode(nodes *[]Node, paths []string, p *profile.Profile)</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file6-67');">func index(nodes []Node, name string) int</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file6-86');">func mergeSingreDir(nodes []Node) []Node</span></td>
							<td class="cov">100%</td>
						</tr>
						
					</table>

					<div class="source">
						<pre><ol><li id="file6-1">package tree
</li><li id="file6-2">
</li><li id="file6-3">import (
</li><li id="file6-4">        "path/filepath"
</li><li id="file6-5">        "strings"
</li><li id="file6-6">
</li><li id="file6-7">        "github.com/masakurapa/gover-html/internal/profile"
</li><li id="file6-8">)
</li><li id="file6-9">
</li><li id="file6-10">// Node is single node of directory tree
</li><li id="file6-11">type Node struct {
</li><li id="file6-12">        Name  string
</li><li id="file6-13">        Files profile.Profiles
</li><li id="file6-14">        Dirs  []Node
</li><li id="file6-15">}
</li><li id="file6-16">
</li><li id="file6-17">// ChildBlocks returns all child Blocks for Node
</li><li id="file6-18">func (n *Node) ChildBlocks() profile.Blocks <span class="cov1">{
</span></li><li id="file6-19"><span class="cov1">        blocks := make(profile.Blocks, 0)
</span></li><li id="file6-20"><span class="cov1">        for _, f := range n.Files </span><span class="cov1">{
</span></li><li id="file6-21"><span class="cov1">                blocks = append(blocks, f.Blocks...)
</span></li><li id="file6-22"><span class="cov1">        }</span>
</li><li id="file6-23">        <span class="cov1">for _, ch := range n.Dirs </span><span class="cov1">{
</span></li><li id="file6-24"><span class="cov1">                blocks = append(blocks, ch.ChildBlocks()...)
</span></li><li id="file6-25"><span class="cov1">        }</span>
</li><li id="file6-26">        <span class="cov1">return blocks</span>
</li><li id="file6-27">}
</li><li id="file6-28">
</li><li id="file6-29">// Create returns directory tree
</li><li id="file6-30">func Create(profiles profile.Profiles) []Node <span class="cov1">{
</span></li><li id="file6-31"><span class="cov1">        nodes := make([]Node, 0)
</span></li><li id="file6-32"><span class="cov1">        for _, p := range profiles </span><span class="cov1">{
</span></li><li id="file6-33"><span class="cov1">                idx := index(nodes, p.ModulePath)
</span></li><li id="file6-34"><span class="cov1">                if idx == -1 </span><span class="cov1">{
</span></li><li id="file6-35"><span class="cov1">                        nodes = append(nodes, Node{Name: p.ModulePath})
</span></li><li id="file6-36"><span class="cov1">                        idx = len(nodes) - 1
</span></li><li id="file6-37"><span class="cov1">                }</span>
</li><li id="file6-38">
</li><li id="file6-39">                <span class="cov1">addNode(&amp;nodes[idx].Dirs, strings.Split(p.RemoveModulePathFromFileName(), "/"), &amp;p)</span>
</li><li id="file6-40">        }
</li><li id="file6-41">
</li><li id="file6-42">        <span class="cov1">for i, node := range nodes </span><span class="cov1">{
</span></li><li id="file6-43"><span class="cov1">                nodes[i].Dirs = mergeSingreDir(node.Dirs)
</span></li><li id="file6-44"><span class="cov1">        }</span>
</li><li id="file6-45">        <span class="cov1">return nodes</span>
</li><li id="file6-46">}
</li><li id="file6-47">
</li><li id="file6-48">func addNode(nodes *[]Node, paths []string, p *profile.Profile) <span class="cov1">{
</span></li><li id="file6-49"><span class="cov1">        name := paths[0]
</span></li><li id="file6-50"><span class="cov1">        nextPaths := paths[1:]
</span></li><li id="file6-51"><span class="cov1">
</span></li><li id="file6-52"><span class="cov1">        idx := index(*nodes, name)
</span></li><li id="file6-53"><span class="cov1">        if idx == -1 </span><span class="cov1">{
</span></li><li id="file6-54"><span class="cov1">                *nodes = append(*nodes, Node{Name: name})
</span></li><li id="file6-55"><span class="cov1">                idx = len(*nodes) - 1
</span></li><li id="file6-56"><span class="cov1">        }</span>
</li><li id="file6-57">
</li><li id="file6-58">        <span class="cov1">n := *nodes
</span></li><li id="file6-59"><span class="cov1">        if len(nextPaths) == 1 </span><span class="cov1">{
</span></li><li id="file6-60"><span class="cov1">                n[idx].Files = append(n[idx].Files, *p)
</span></li><li id="file6-61"><span class="cov1">                return
</span></li><li id="file6-62"><span class="cov1">        }</span>
</li><li id="file6-63">
</li><li id="file6-64">        <span class="cov1">addNode(&amp;n[idx].Dirs, nextPaths, p)</span>
</li><li id="file6-65">}
</li><li id="file6-66">
</li><li id="file6-67">func index(nodes []Node, name string) int <span class="cov1">{
</span></li><li id="file6-68"><span class="cov1">        for i, t := range nodes </span><span class="cov1">{
</span></li><li id="file6-69"><span class="cov1">                if t.Name == name </span><span class="cov1">{
</span></li><li id="file6-70"><span class="cov1">                        return i
</span></li><li id="file6-71"><span class="cov1">                }</span>
</li><li id="file6-72">        }
</li><li id="file6-73">        <span class="cov1">return -1</span>
</li><li id="file6-74">}
</li><li id="file6-75">
</li><li id="file6-76">// merge directories with no files and only one child directory
</li><li id="file6-77">//
</li><li id="file6-78">//        path/
</li><li id="file6-79">//                to/
</li><li id="file6-80">//                file.go
</li><li id="file6-81">//
</li><li id="file6-82">// to
</li><li id="file6-83">//
</li><li id="file6-84">//        path/to/
</li><li id="file6-85">//                file.go
</li><li id="file6-86">func mergeSingreDir(nodes []Node) []Node <span class="cov1">{
</span></li><li id="file6-87"><span class="cov1">        for i, n := range nodes </span><span class="cov1">{
</span></li><li id="file6-88"><span class="cov1">                if len(n.Dirs) == 0 </span><span class="cov1">{
</span></li><li id="file6-89"><span class="cov1">                        continue</span>
</li><li id="file6-90">                }
</li><li id="file6-91">
</li><li id="file6-92">                <span class="cov1">mergeSingreDir(n.Dirs)
</span></li><li id="file6-93"><span class="cov1">                if len(n.Files) &gt; 0 || len(n.Dirs) != 1 </span><span class="cov1">{
</span></li><li id="file6-94"><span class="cov1">                        continue</span>
</li><li id="file6-95">                }
</li><li id="file6-96">
</li><li id="file6-97">                <span class="cov1">sub := n.Dirs[0]
</span></li><li id="file6-98"><span class="cov1">                nodes[i].Name = filepath.Join(n.Name, sub.Name)
</span></li><li id="file6-99"><span class="cov1">                nodes[i].Files = sub.Files
</span></li><li id="file6-100"><span class="cov1">                nodes[i].Dirs = sub.Dirs</span>
</li><li id="file6-101">        }
</li><li id="file6-102">        <span class="cov1">return nodes</span>
</li><li id="file6-103">}
</li></ol></pre>
					</div>
				</div>
				
				<div id="file7"  style="display: none">
					<table>
						<tr><th colspan="2">Coverages</th></tr>
						<tr><td class="total">Total</td><td class="cov">0%</td></tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file7-7');">func (e *optionErrors) Error() string</span></td>
							<td class="cov">0%</td>
						</tr>
						
					</table>

					<div class="source">
						<pre><ol><li id="file7-1">package option
</li><li id="file7-2">
</li><li id="file7-3">import "strings"
</li><li id="file7-4">
</li><li id="file7-5">type optionErrors []error
</li><li id="file7-6">
</li><li id="file7-7">func (e *optionErrors) Error() string <span class="cov0">{
</span></li><li id="file7-8"><span class="cov0">        messages := make([]string, 0, len(*e))
</span></li><li id="file7-9"><span class="cov0">        for _, err := range *e </span><span class="cov0">{
</span></li><li id="file7-10"><span class="cov0">                messages = append(messages, err.Error())
</span></li><li id="file7-11"><span class="cov0">        }</span>
</li><li id="file7-12">        <span class="cov0">return strings.Join(messages, "\n")</span>
</li><li id="file7-13">}
</li></ol></pre>
					</div>
				</div>
				
				<div id="file8"  style="display: none">
					<table>
						<tr><th colspan="2">Coverages</th></tr>
						<tr><td class="total">Total</td><td class="cov">96.3%</td></tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-60');">func New(r reader.Reader) *Generator</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-64');">func (g *Generator) Generate(input *string, output *string, theme *string, include *string, exclude *string, excludeFunc *string) (*Option, error)</span></td>
							<td class="cov">92.3%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-90');">func (g *Generator) readOptionFile() (*optionConfig, error)</span></td>
							<td class="cov">70%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-109');">func (g *Generator) stringValue(arg *string, opt string) string</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-116');">func (g *Generator) stringsValue(arg *string, opt []string) []string</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-123');">func (g *Generator) getValidatedOption(opt *optionConfig) (*Option, error)</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-130');">func (g *Generator) validate(opt *optionConfig) error</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-153');">func (g *Generator) validateFilter(f string, values []string) optionErrors</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-167');">func (g *Generator) validateExcludeFunc(values []string) optionErrors</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-191');">func (g *Generator) getOptionWithDefaultValue(opt *optionConfig) *Option</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-216');">func (g *Generator) isEmpty(s string) bool</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-220');">func (g *Generator) convertFilterValue(values []string) []string</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file8-235');">func (g *Generator) convertExcludeFuncOption(values []string) []ExcludeFuncOption</span></td>
							<td class="cov">100%</td>
						</tr>
						
					</table>

					<div class="source">
						<pre><ol><li id="file8-1">package option
</li><li id="file8-2">
</li><li id="file8-3">import (
</li><li id="file8-4">        "fmt"
</li><li id="file8-5">        "io"
</li><li id="file8-6">        "regexp"
</li><li id="file8-7">        "strings"
</li><li id="file8-8">
</li><li id="file8-9">        "github.com/masakurapa/gover-html/internal/reader"
</li><li id="file8-10">
</li><li id="file8-11">        "gopkg.in/yaml.v2"
</li><li id="file8-12">)
</li><li id="file8-13">
</li><li id="file8-14">const (
</li><li id="file8-15">        fileName = ".gover.yml"
</li><li id="file8-16">
</li><li id="file8-17">        optionSeparator = ","
</li><li id="file8-18">
</li><li id="file8-19">        inputDefault  = "coverage.out"
</li><li id="file8-20">        outputDefault = "coverage.html"
</li><li id="file8-21">
</li><li id="file8-22">        themeDark    = "dark"
</li><li id="file8-23">        themeLight   = "light"
</li><li id="file8-24">        themeDefault = themeDark
</li><li id="file8-25">)
</li><li id="file8-26">
</li><li id="file8-27">var (
</li><li id="file8-28">        // 関数除外設定の検証用の正規表現（ここでは緩い検証にする）
</li><li id="file8-29">        excludeFuncFormat = regexp.MustCompile(`^\((.+)\)\.([a-zA-Z].+)$`)
</li><li id="file8-30">)
</li><li id="file8-31">
</li><li id="file8-32">type optionConfig struct {
</li><li id="file8-33">        Input       string
</li><li id="file8-34">        Output      string
</li><li id="file8-35">        Theme       string
</li><li id="file8-36">        Include     []string // include fire or directories
</li><li id="file8-37">        Exclude     []string // exclude fire or directories
</li><li id="file8-38">        ExcludeFunc []string `yaml:"exclude-func"` // exclude functions
</li><li id="file8-39">}
</li><li id="file8-40">
</li><li id="file8-41">type Option struct {
</li><li id="file8-42">        Input       string
</li><li id="file8-43">        Output      string
</li><li id="file8-44">        Theme       string
</li><li id="file8-45">        Include     []string            // include fire or directories
</li><li id="file8-46">        Exclude     []string            // exclude fire or directories
</li><li id="file8-47">        ExcludeFunc []ExcludeFuncOption // exclude functions
</li><li id="file8-48">}
</li><li id="file8-49">
</li><li id="file8-50">type ExcludeFuncOption struct {
</li><li id="file8-51">        Path   string
</li><li id="file8-52">        Struct string
</li><li id="file8-53">        Func   string
</li><li id="file8-54">}
</li><li id="file8-55">
</li><li id="file8-56">type Generator struct {
</li><li id="file8-57">        r reader.Reader
</li><li id="file8-58">}
</li><li id="file8-59">
</li><li id="file8-60">func New(r reader.Reader) *Generator <span class="cov1">{
</span></li><li id="file8-61"><span class="cov1">        return &amp;Generator{r: r}
</span></li><li id="file8-62"><span class="cov1">}</span>
</li><li id="file8-63">
</li><li id="file8-64">func (g *Generator) Generate(
</li><li id="file8-65">        input *string,
</li><li id="file8-66">        output *string,
</li><li id="file8-67">        theme *string,
</li><li id="file8-68">        include *string,
</li><li id="file8-69">        exclude *string,
</li><li id="file8-70">        excludeFunc *string,
</li><li id="file8-71">) (*Option, error) <span class="cov1">{
</span></li><li id="file8-72"><span class="cov1">        opt := &amp;optionConfig{}
</span></li><li id="file8-73"><span class="cov1">        if g.r.Exists(fileName) </span><span class="cov1">{
</span></li><li id="file8-74"><span class="cov1">                fileOpt, err := g.readOptionFile()
</span></li><li id="file8-75"><span class="cov1">                if err != nil </span><span class="cov0">{
</span></li><li id="file8-76"><span class="cov0">                        return nil, err
</span></li><li id="file8-77"><span class="cov0">                }</span>
</li><li id="file8-78">                <span class="cov1">opt = fileOpt</span>
</li><li id="file8-79">        }
</li><li id="file8-80">
</li><li id="file8-81">        <span class="cov1">opt.Input = g.stringValue(input, opt.Input)
</span></li><li id="file8-82"><span class="cov1">        opt.Output = g.stringValue(output, opt.Output)
</span></li><li id="file8-83"><span class="cov1">        opt.Theme = g.stringValue(theme, opt.Theme)
</span></li><li id="file8-84"><span class="cov1">        opt.Include = g.stringsValue(include, opt.Include)
</span></li><li id="file8-85"><span class="cov1">        opt.Exclude = g.stringsValue(exclude, opt.Exclude)
</span></li><li id="file8-86"><span class="cov1">        opt.ExcludeFunc = g.stringsValue(excludeFunc, opt.ExcludeFunc)
</span></li><li id="file8-87"><span class="cov1">        return g.getValidatedOption(opt)</span>
</li><li id="file8-88">}
</li><li id="file8-89">
</li><li id="file8-90">func (g *Generator) readOptionFile() (*optionConfig, error) <span class="cov1">{
</span></li><li id="file8-91"><span class="cov1">        r, err := g.r.Read(fileName)
</span></li><li id="file8-92"><span class="cov1">        if err != nil </span><span class="cov0">{
</span></li><li id="file8-93"><span class="cov0">                return nil, err
</span></li><li id="file8-94"><span class="cov0">        }</span>
</li><li id="file8-95">
</li><li id="file8-96">        <span class="cov1">b, err := io.ReadAll(r)
</span></li><li id="file8-97"><span class="cov1">        if err != nil </span><span class="cov0">{
</span></li><li id="file8-98"><span class="cov0">                return nil, err
</span></li><li id="file8-99"><span class="cov0">        }</span>
</li><li id="file8-100">
</li><li id="file8-101">        <span class="cov1">opt := optionConfig{}
</span></li><li id="file8-102"><span class="cov1">        if err := yaml.Unmarshal(b, &amp;opt); err != nil </span><span class="cov0">{
</span></li><li id="file8-103"><span class="cov0">                return nil, err
</span></li><li id="file8-104"><span class="cov0">        }</span>
</li><li id="file8-105">
</li><li id="file8-106">        <span class="cov1">return &amp;opt, nil</span>
</li><li id="file8-107">}
</li><li id="file8-108">
</li><li id="file8-109">func (g *Generator) stringValue(arg *string, opt string) string <span class="cov1">{
</span></li><li id="file8-110"><span class="cov1">        if arg == nil </span><span class="cov1">{
</span></li><li id="file8-111"><span class="cov1">                return opt
</span></li><li id="file8-112"><span class="cov1">        }</span>
</li><li id="file8-113">        <span class="cov1">return *arg</span>
</li><li id="file8-114">}
</li><li id="file8-115">
</li><li id="file8-116">func (g *Generator) stringsValue(arg *string, opt []string) []string <span class="cov1">{
</span></li><li id="file8-117"><span class="cov1">        if arg == nil </span><span class="cov1">{
</span></li><li id="file8-118"><span class="cov1">                return opt
</span></li><li id="file8-119"><span class="cov1">        }</span>
</li><li id="file8-120">        <span class="cov1">return strings.Split(*arg, optionSeparator)</span>
</li><li id="file8-121">}
</li><li id="file8-122">
</li><li id="file8-123">func (g *Generator) getValidatedOption(opt *optionConfig) (*Option, error) <span class="cov1">{
</span></li><li id="file8-124"><span class="cov1">        if err := g.validate(opt); err != nil </span><span class="cov1">{
</span></li><li id="file8-125"><span class="cov1">                return nil, err
</span></li><li id="file8-126"><span class="cov1">        }</span>
</li><li id="file8-127">        <span class="cov1">return g.getOptionWithDefaultValue(opt), nil</span>
</li><li id="file8-128">}
</li><li id="file8-129">
</li><li id="file8-130">func (g *Generator) validate(opt *optionConfig) error <span class="cov1">{
</span></li><li id="file8-131"><span class="cov1">        errs := make(optionErrors, 0)
</span></li><li id="file8-132"><span class="cov1">
</span></li><li id="file8-133"><span class="cov1">        if !g.isEmpty(opt.Theme) &amp;&amp; opt.Theme != themeDark &amp;&amp; opt.Theme != themeLight </span><span class="cov1">{
</span></li><li id="file8-134"><span class="cov1">                errs = append(errs, fmt.Errorf("theme must be %q or %q", themeDark, themeLight))
</span></li><li id="file8-135"><span class="cov1">        }</span>
</li><li id="file8-136">
</li><li id="file8-137">        <span class="cov1">if es := g.validateFilter("include", opt.Include); len(es) &gt; 0 </span><span class="cov1">{
</span></li><li id="file8-138"><span class="cov1">                errs = append(errs, es...)
</span></li><li id="file8-139"><span class="cov1">        }</span>
</li><li id="file8-140">        <span class="cov1">if es := g.validateFilter("exclude", opt.Exclude); len(es) &gt; 0 </span><span class="cov1">{
</span></li><li id="file8-141"><span class="cov1">                errs = append(errs, es...)
</span></li><li id="file8-142"><span class="cov1">        }</span>
</li><li id="file8-143">        <span class="cov1">if es := g.validateExcludeFunc(opt.ExcludeFunc); len(es) &gt; 0 </span><span class="cov1">{
</span></li><li id="file8-144"><span class="cov1">                errs = append(errs, es...)
</span></li><li id="file8-145"><span class="cov1">        }</span>
</li><li id="file8-146">
</li><li id="file8-147">        <span class="cov1">if len(errs) &gt; 0 </span><span class="cov1">{
</span></li><li id="file8-148"><span class="cov1">                return &amp;errs
</span></li><li id="file8-149"><span class="cov1">        }</span>
</li><li id="file8-150">        <span class="cov1">return nil</span>
</li><li id="file8-151">}
</li><li id="file8-152">
</li><li id="file8-153">func (g *Generator) validateFilter(f string, values []string) optionErrors <span class="cov1">{
</span></li><li id="file8-154"><span class="cov1">        errs := make(optionErrors, 0)
</span></li><li id="file8-155"><span class="cov1">        for _, v := range values </span><span class="cov1">{
</span></li><li id="file8-156"><span class="cov1">                if g.isEmpty(v) </span><span class="cov1">{
</span></li><li id="file8-157"><span class="cov1">                        continue</span>
</li><li id="file8-158">                }
</li><li id="file8-159">
</li><li id="file8-160">                <span class="cov1">if strings.HasPrefix(v, "/") </span><span class="cov1">{
</span></li><li id="file8-161"><span class="cov1">                        errs = append(errs, fmt.Errorf("%s value %q must not be an absolute path", f, v))
</span></li><li id="file8-162"><span class="cov1">                }</span>
</li><li id="file8-163">        }
</li><li id="file8-164">        <span class="cov1">return errs</span>
</li><li id="file8-165">}
</li><li id="file8-166">
</li><li id="file8-167">func (g *Generator) validateExcludeFunc(values []string) optionErrors <span class="cov1">{
</span></li><li id="file8-168"><span class="cov1">        errs := make(optionErrors, 0)
</span></li><li id="file8-169"><span class="cov1">        for _, v := range values </span><span class="cov1">{
</span></li><li id="file8-170"><span class="cov1">                if g.isEmpty(v) </span><span class="cov1">{
</span></li><li id="file8-171"><span class="cov1">                        continue</span>
</li><li id="file8-172">                }
</li><li id="file8-173">
</li><li id="file8-174">                <span class="cov1">if strings.HasPrefix(v, "(/") </span><span class="cov1">{
</span></li><li id="file8-175"><span class="cov1">                        errs = append(errs, fmt.Errorf("exclude-func value %q must not be an absolute path", v))
</span></li><li id="file8-176"><span class="cov1">                        continue</span>
</li><li id="file8-177">                }
</li><li id="file8-178">
</li><li id="file8-179">                // ()が含まれない場合は関数名のみとみなしてOK
</li><li id="file8-180">                <span class="cov1">if !strings.Contains(v, "(") &amp;&amp; !strings.Contains(v, ")") </span><span class="cov1">{
</span></li><li id="file8-181"><span class="cov1">                        continue</span>
</li><li id="file8-182">                }
</li><li id="file8-183">
</li><li id="file8-184">                <span class="cov1">if !excludeFuncFormat.MatchString(v) </span><span class="cov1">{
</span></li><li id="file8-185"><span class="cov1">                        errs = append(errs, fmt.Errorf("exclude-func value %q format is invalid", v))
</span></li><li id="file8-186"><span class="cov1">                }</span>
</li><li id="file8-187">        }
</li><li id="file8-188">        <span class="cov1">return errs</span>
</li><li id="file8-189">}
</li><li id="file8-190">
</li><li id="file8-191">func (g *Generator) getOptionWithDefaultValue(opt *optionConfig) *Option <span class="cov1">{
</span></li><li id="file8-192"><span class="cov1">        newOpt := &amp;Option{
</span></li><li id="file8-193"><span class="cov1">                Input:   opt.Input,
</span></li><li id="file8-194"><span class="cov1">                Output:  opt.Output,
</span></li><li id="file8-195"><span class="cov1">                Theme:   opt.Theme,
</span></li><li id="file8-196"><span class="cov1">                Include: opt.Include,
</span></li><li id="file8-197"><span class="cov1">                Exclude: opt.Exclude,
</span></li><li id="file8-198"><span class="cov1">        }
</span></li><li id="file8-199"><span class="cov1">
</span></li><li id="file8-200"><span class="cov1">        if g.isEmpty(newOpt.Input) </span><span class="cov1">{
</span></li><li id="file8-201"><span class="cov1">                newOpt.Input = inputDefault
</span></li><li id="file8-202"><span class="cov1">        }</span>
</li><li id="file8-203">        <span class="cov1">if g.isEmpty(newOpt.Output) </span><span class="cov1">{
</span></li><li id="file8-204"><span class="cov1">                newOpt.Output = outputDefault
</span></li><li id="file8-205"><span class="cov1">        }</span>
</li><li id="file8-206">        <span class="cov1">if g.isEmpty(newOpt.Theme) </span><span class="cov1">{
</span></li><li id="file8-207"><span class="cov1">                newOpt.Theme = themeDefault
</span></li><li id="file8-208"><span class="cov1">        }</span>
</li><li id="file8-209">
</li><li id="file8-210">        <span class="cov1">newOpt.Include = g.convertFilterValue(newOpt.Include)
</span></li><li id="file8-211"><span class="cov1">        newOpt.Exclude = g.convertFilterValue(newOpt.Exclude)
</span></li><li id="file8-212"><span class="cov1">        newOpt.ExcludeFunc = g.convertExcludeFuncOption(opt.ExcludeFunc)
</span></li><li id="file8-213"><span class="cov1">        return newOpt</span>
</li><li id="file8-214">}
</li><li id="file8-215">
</li><li id="file8-216">func (g *Generator) isEmpty(s string) bool <span class="cov1">{
</span></li><li id="file8-217"><span class="cov1">        return s == ""
</span></li><li id="file8-218"><span class="cov1">}</span>
</li><li id="file8-219">
</li><li id="file8-220">func (g *Generator) convertFilterValue(values []string) []string <span class="cov1">{
</span></li><li id="file8-221"><span class="cov1">        ret := make([]string, 0, len(values))
</span></li><li id="file8-222"><span class="cov1">        for _, v := range values </span><span class="cov1">{
</span></li><li id="file8-223"><span class="cov1">                s := strings.TrimSpace(v)
</span></li><li id="file8-224"><span class="cov1">                if g.isEmpty(s) </span><span class="cov1">{
</span></li><li id="file8-225"><span class="cov1">                        continue</span>
</li><li id="file8-226">                }
</li><li id="file8-227">
</li><li id="file8-228">                <span class="cov1">s = strings.TrimPrefix(s, "./")
</span></li><li id="file8-229"><span class="cov1">                s = strings.TrimSuffix(s, "/")
</span></li><li id="file8-230"><span class="cov1">                ret = append(ret, s)</span>
</li><li id="file8-231">        }
</li><li id="file8-232">        <span class="cov1">return ret</span>
</li><li id="file8-233">}
</li><li id="file8-234">
</li><li id="file8-235">func (g *Generator) convertExcludeFuncOption(values []string) []ExcludeFuncOption <span class="cov1">{
</span></li><li id="file8-236"><span class="cov1">        ret := make([]ExcludeFuncOption, 0, len(values))
</span></li><li id="file8-237"><span class="cov1">        for _, v := range values </span><span class="cov1">{
</span></li><li id="file8-238"><span class="cov1">                s := strings.TrimSpace(v)
</span></li><li id="file8-239"><span class="cov1">                if g.isEmpty(s) </span><span class="cov1">{
</span></li><li id="file8-240"><span class="cov1">                        continue</span>
</li><li id="file8-241">                }
</li><li id="file8-242">
</li><li id="file8-243">                // ()が含まれない場合は関数名のみとみなして終了
</li><li id="file8-244">                <span class="cov1">if !strings.Contains(s, "(") &amp;&amp; !strings.Contains(s, ")") </span><span class="cov1">{
</span></li><li id="file8-245"><span class="cov1">                        ret = append(ret, ExcludeFuncOption{Func: s})
</span></li><li id="file8-246"><span class="cov1">                        continue</span>
</li><li id="file8-247">                }
</li><li id="file8-248">
</li><li id="file8-249">                // excludeFuncFormat = regexp.MustCompile(`^\(.+\)\.([a-zA-Z].+)$`)
</li><li id="file8-250">
</li><li id="file8-251">                <span class="cov1">matches := excludeFuncFormat.FindStringSubmatch(s)
</span></li><li id="file8-252"><span class="cov1">                optPath := strings.TrimSuffix(strings.TrimPrefix(matches[1], "./"), "/")
</span></li><li id="file8-253"><span class="cov1">
</span></li><li id="file8-254"><span class="cov1">                var path, structName string
</span></li><li id="file8-255"><span class="cov1">                idx := strings.LastIndex(optPath, ".")
</span></li><li id="file8-256"><span class="cov1">
</span></li><li id="file8-257"><span class="cov1">                if idx == -1 </span><span class="cov1">{
</span></li><li id="file8-258"><span class="cov1">                        // ファイル名で指定していない or 構造体名未指定
</span></li><li id="file8-259"><span class="cov1">                        path = optPath
</span></li><li id="file8-260"><span class="cov1">                }</span> else<span class="cov1"> {
</span></li><li id="file8-261"><span class="cov1">                        s := optPath[idx+1:]
</span></li><li id="file8-262"><span class="cov1">                        if s == "go" </span><span class="cov1">{
</span></li><li id="file8-263"><span class="cov1">                                // ファイル名のみ指定している
</span></li><li id="file8-264"><span class="cov1">                                path = optPath
</span></li><li id="file8-265"><span class="cov1">                        }</span> else<span class="cov1"> {
</span></li><li id="file8-266"><span class="cov1">                                path = optPath[:idx]
</span></li><li id="file8-267"><span class="cov1">                                structName = s
</span></li><li id="file8-268"><span class="cov1">                        }</span>
</li><li id="file8-269">                }
</li><li id="file8-270">
</li><li id="file8-271">                <span class="cov1">if path == "*" </span><span class="cov1">{
</span></li><li id="file8-272"><span class="cov1">                        path = ""
</span></li><li id="file8-273"><span class="cov1">                }</span>
</li><li id="file8-274">
</li><li id="file8-275">                <span class="cov1">ret = append(ret, ExcludeFuncOption{
</span></li><li id="file8-276"><span class="cov1">                        Path:   strings.TrimSuffix(strings.TrimPrefix(path, "./"), "/"),
</span></li><li id="file8-277"><span class="cov1">                        Struct: structName,
</span></li><li id="file8-278"><span class="cov1">                        Func:   matches[2],
</span></li><li id="file8-279"><span class="cov1">                })</span>
</li><li id="file8-280">        }
</li><li id="file8-281">        <span class="cov1">return ret</span>
</li><li id="file8-282">}
</li></ol></pre>
					</div>
				</div>
				
				<div id="file9"  style="display: none">
					<table>
						<tr><th colspan="2">Coverages</th></tr>
						<tr><td class="total">Total</td><td class="cov">92.3%</td></tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file9-48');">func (prof *Profile) IsRelativeOrAbsolute() bool</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file9-53');">func (prof *Profile) RemoveModulePathFromFileName() string</span></td>
							<td class="cov">0%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file9-58');">func (prof *Profile) FilePath() string</span></td>
							<td class="cov">100%</td>
						</tr>
						
						<tr>
							<td class="fnc"><span class="clickable" onclick="scrollById('file9-66');">func (blocks *Blocks) Coverage() float64</span></td>
							<td class="cov">100%</td>
						</tr>
						
					</table>

					<div class="source">
						<pre><ol><li id="file9-1">package profile
</li><li id="file9-2">
</li><li id="file9-3">import (
</li><li id="file9-4">        "math"
</li><li id="file9-5">        "path"
</li><li id="file9-6">        "path/filepath"
</li><li id="file9-7">        "strings"
</li><li id="file9-8">)
</li><li id="file9-9">
</li><li id="file9-10">// Profiles is a type that represents a slice of Profile
</li><li id="file9-11">type Profiles []Profile
</li><li id="file9-12">
</li><li id="file9-13">// Profile is profiling data for each file
</li><li id="file9-14">type Profile struct {
</li><li id="file9-15">        ID         int
</li><li id="file9-16">        ModulePath string
</li><li id="file9-17">        Dir        string
</li><li id="file9-18">        FileName   string
</li><li id="file9-19">        Blocks     Blocks
</li><li id="file9-20">        Functions  Functions
</li><li id="file9-21">}
</li><li id="file9-22">
</li><li id="file9-23">// Functions is a type that represents a slice of Function
</li><li id="file9-24">type Functions []Function
</li><li id="file9-25">
</li><li id="file9-26">// Function is single func of profiling data
</li><li id="file9-27">type Function struct {
</li><li id="file9-28">        Name      string
</li><li id="file9-29">        StartLine int
</li><li id="file9-30">        StartCol  int
</li><li id="file9-31">        Blocks    Blocks
</li><li id="file9-32">}
</li><li id="file9-33">
</li><li id="file9-34">// Blocks is a type that represents a slice of Block
</li><li id="file9-35">type Blocks []Block
</li><li id="file9-36">
</li><li id="file9-37">// Block is single block of profiling data
</li><li id="file9-38">type Block struct {
</li><li id="file9-39">        StartLine int
</li><li id="file9-40">        StartCol  int
</li><li id="file9-41">        EndLine   int
</li><li id="file9-42">        EndCol    int
</li><li id="file9-43">        NumState  int
</li><li id="file9-44">        Count     int
</li><li id="file9-45">}
</li><li id="file9-46">
</li><li id="file9-47">// IsRelativeOrAbsolute returns true if FileName is relative path or absolute path
</li><li id="file9-48">func (prof *Profile) IsRelativeOrAbsolute() bool <span class="cov1">{
</span></li><li id="file9-49"><span class="cov1">        return strings.HasPrefix(prof.FileName, ".") || filepath.IsAbs(prof.FileName)
</span></li><li id="file9-50"><span class="cov1">}</span>
</li><li id="file9-51">
</li><li id="file9-52">// RemoveModulePathFromFileName returns FileName with ModulePath removed
</li><li id="file9-53">func (prof *Profile) RemoveModulePathFromFileName() string <span class="cov0">{
</span></li><li id="file9-54"><span class="cov0">        return strings.TrimPrefix(strings.TrimPrefix(prof.FileName, prof.ModulePath), "/")
</span></li><li id="file9-55"><span class="cov0">}</span>
</li><li id="file9-56">
</li><li id="file9-57">// FilePath returns readable file path
</li><li id="file9-58">func (prof *Profile) FilePath() string <span class="cov1">{
</span></li><li id="file9-59"><span class="cov1">        if prof.IsRelativeOrAbsolute() </span><span class="cov1">{
</span></li><li id="file9-60"><span class="cov1">                return prof.FileName
</span></li><li id="file9-61"><span class="cov1">        }</span>
</li><li id="file9-62">        <span class="cov1">return filepath.Join(prof.Dir, path.Base(prof.FileName))</span>
</li><li id="file9-63">}
</li><li id="file9-64">
</li><li id="file9-65">// Coverage returns covered ratio for file
</li><li id="file9-66">func (blocks *Blocks) Coverage() float64 <span class="cov1">{
</span></li><li id="file9-67"><span class="cov1">        var total, covered int64
</span></li><li id="file9-68"><span class="cov1">        for _, b := range *blocks </span><span class="cov1">{
</span></li><li id="file9-69"><span class="cov1">                total += int64(b.NumState)
</span></li><li id="file9-70"><span class="cov1">                if b.Count &gt; 0 </span><span class="cov1">{
</span></li><li id="file9-71"><span class="cov1">                        covered += int64(b.NumState)
</span></li><li id="file9-72"><span class="cov1">                }</span>
</li><li id="file9-73">        }
</li><li id="file9-74">
</li><li id="file9-75">        <span class="cov1">if total == 0 </span><span class="cov1">{
</span></li><li id="file9-76"><span class="cov1">                return 0
</span></li><li id="file9-77"><span class="cov1">        }</span>
</li><li id="file9-78">
</li><li id="file9-79">        <span class="cov1">return math.Round((float64(covered)/float64(total)*100)*10) / 10</span>
</li><li id="file9-80">}
</li></ol></pre>
					</div>
				</div>
				
			</div>
		</div>

		<script>
			
			const scrollWidth = document.getElementById('tree').scrollWidth;

			let current;
			let currentTree;
			updateByQuery();

			window.addEventListener('popstate', function(e) {
				updateByQuery();
			})

			function updateByQuery() {
				const searchParams = new URLSearchParams(window.location.search);
				const n = searchParams.get('n');
				const i = searchParams.get('i');
				if (n && i) {
					change(n, i);
				} 
			}

			function select(n) {
				if (current) {
					current.style.display = 'none';
				}

				current = document.getElementById('file' + n);
				if (!current) {
					return;
				}
				current.style.display = 'block';
				scrollById('coverage');
			}
			function selectTree(n, indent) {
				if (currentTree) {
					currentTree.classList.remove('current');
				}

				currentTree = document.getElementById('tree' + n);
				if (!current) {
					return;
				}
				currentTree.classList.add('current');
				currentTree.style.width = scrollWidth - (indent * 30 + 8) + 'px';
			}
			function scrollById(id) {
				const elm = document.getElementById(id);
				const rect = elm.getBoundingClientRect();
				document.documentElement.scrollTop = rect.top + window.pageYOffset;
			}
			function change(n, i) {
				select(n);
				selectTree(n, i);
				updateUrl(n, i)
			}
			function updateUrl(n, i) {
				const url = new URL(window.location.href);
				if( !url.searchParams.get('n') ) {
					url.searchParams.append('n',n);
					url.searchParams.append('i',i);
					location.href = url;
				} else {
					if (url.searchParams.get('n') != n || url.searchParams.get('i') != i) {
						url.searchParams.set('n',n);
						url.searchParams.set('i',i);
						history.pushState("", "", url);
					}
				}
			}
		</script>
	</body>
</html>
